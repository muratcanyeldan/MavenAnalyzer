{"ast":null,"code":"import n from \"lodash/uniq\";\nimport t from \"lodash/uniqBy\";\nimport r from \"lodash/sortBy\";\nimport e from \"lodash/last\";\nimport a from \"lodash/isDate\";\nimport { utcParse as i, timeParse as o } from \"d3-time-format\";\nimport { scaleLinear as u, scalePoint as c, scaleBand as s, scaleUtc as d, scaleTime as f, scaleLog as l, scaleSymlog as m } from \"d3-scale\";\nimport { timeInterval as v, timeMillisecond as y, utcMillisecond as p, timeSecond as h, utcSecond as g, timeMinute as x, utcMinute as k, timeHour as T, utcHour as b, timeWeek as M, utcWeek as w, timeSunday as E, utcSunday as S, timeMonday as D, utcMonday as C, timeTuesday as U, utcTuesday as j, timeWednesday as O, utcWednesday as R, timeThursday as H, utcThursday as V, timeFriday as q, utcFriday as A, timeSaturday as B, utcSaturday as F, timeMonth as N, utcMonth as z, timeYear as I, utcYear as P } from \"d3-time\";\nfunction $() {\n  return $ = Object.assign ? Object.assign.bind() : function (n) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n      for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (n[e] = r[e]);\n    }\n    return n;\n  }, $.apply(this, arguments);\n}\nvar G = [\"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"month\", \"year\"],\n  J = [function (n) {\n    return n.setMilliseconds(0);\n  }, function (n) {\n    return n.setSeconds(0);\n  }, function (n) {\n    return n.setMinutes(0);\n  }, function (n) {\n    return n.setHours(0);\n  }, function (n) {\n    return n.setDate(1);\n  }, function (n) {\n    return n.setMonth(0);\n  }],\n  K = {\n    millisecond: [],\n    second: J.slice(0, 1),\n    minute: J.slice(0, 2),\n    hour: J.slice(0, 3),\n    day: J.slice(0, 4),\n    month: J.slice(0, 5),\n    year: J.slice(0, 6)\n  },\n  L = function (n) {\n    return function (t) {\n      return K[n].forEach(function (n) {\n        n(t);\n      }), t;\n    };\n  },\n  Q = function (n) {\n    var t = n.format,\n      r = void 0 === t ? \"native\" : t,\n      e = n.precision,\n      a = void 0 === e ? \"millisecond\" : e,\n      u = n.useUTC,\n      c = void 0 === u || u,\n      s = L(a);\n    return function (n) {\n      if (void 0 === n) return n;\n      if (\"native\" === r || n instanceof Date) return s(n);\n      var t = c ? i(r) : o(r);\n      return s(t(n));\n    };\n  },\n  W = function (n, t, r, e) {\n    var a,\n      i,\n      o,\n      c,\n      s = n.min,\n      d = void 0 === s ? 0 : s,\n      f = n.max,\n      l = void 0 === f ? \"auto\" : f,\n      m = n.stacked,\n      v = void 0 !== m && m,\n      y = n.reverse,\n      p = void 0 !== y && y,\n      h = n.clamp,\n      g = void 0 !== h && h,\n      x = n.nice,\n      k = void 0 !== x && x;\n    \"auto\" === d ? a = !0 === v ? null != (i = t.minStacked) ? i : 0 : t.min : a = d;\n    \"auto\" === l ? o = !0 === v ? null != (c = t.maxStacked) ? c : 0 : t.max : o = l;\n    var T = u().rangeRound(\"x\" === e ? [0, r] : [r, 0]).domain(p ? [o, a] : [a, o]).clamp(g);\n    return !0 === k ? T.nice() : \"number\" == typeof k && T.nice(k), X(T, v);\n  },\n  X = function (n, t) {\n    void 0 === t && (t = !1);\n    var r = n;\n    return r.type = \"linear\", r.stacked = t, r;\n  },\n  Y = function (n, t, r) {\n    var e = c().range([0, r]).domain(t.all);\n    return e.type = \"point\", e;\n  },\n  Z = function (n) {\n    var t = n;\n    return t.type = \"point\", t;\n  },\n  _ = function (n, t, r, e) {\n    var a = n.round,\n      i = void 0 === a || a,\n      o = s().range(\"x\" === e ? [0, r] : [r, 0]).domain(t.all).round(i);\n    return nn(o);\n  },\n  nn = function (n) {\n    var t = n;\n    return t.type = \"band\", t;\n  },\n  tn = function (n, t, r) {\n    var e,\n      a,\n      i = n.format,\n      o = void 0 === i ? \"native\" : i,\n      u = n.precision,\n      c = void 0 === u ? \"millisecond\" : u,\n      s = n.min,\n      l = void 0 === s ? \"auto\" : s,\n      m = n.max,\n      v = void 0 === m ? \"auto\" : m,\n      y = n.useUTC,\n      p = void 0 === y || y,\n      h = n.nice,\n      g = void 0 !== h && h,\n      x = Q({\n        format: o,\n        precision: c,\n        useUTC: p\n      });\n    e = \"auto\" === l ? x(t.min) : \"native\" !== o ? x(l) : l, a = \"auto\" === v ? x(t.max) : \"native\" !== o ? x(v) : v;\n    var k = p ? d() : f();\n    k.range([0, r]), e && a && k.domain([e, a]), !0 === g ? k.nice() : \"object\" != typeof g && \"number\" != typeof g || k.nice(g);\n    var T = k;\n    return T.type = \"time\", T.useUTC = p, T;\n  },\n  rn = function (n, t, r, e) {\n    var a,\n      i = n.base,\n      o = void 0 === i ? 10 : i,\n      u = n.min,\n      c = void 0 === u ? \"auto\" : u,\n      s = n.max,\n      d = void 0 === s ? \"auto\" : s;\n    if (t.all.some(function (n) {\n      return 0 === n;\n    })) throw new Error(\"a log scale domain must not include or cross zero\");\n    var f,\n      m,\n      v = !1;\n    if (t.all.filter(function (n) {\n      return null != n;\n    }).forEach(function (n) {\n      v || (void 0 === a ? a = Math.sign(n) : Math.sign(n) !== a && (v = !0));\n    }), v) throw new Error(\"a log scale domain must be strictly-positive or strictly-negative\");\n    f = \"auto\" === c ? t.min : c, m = \"auto\" === d ? t.max : d;\n    var y = l().domain([f, m]).rangeRound(\"x\" === e ? [0, r] : [r, 0]).base(o).nice();\n    return y.type = \"log\", y;\n  },\n  en = function (n, t, r, e) {\n    var a,\n      i,\n      o = n.constant,\n      u = void 0 === o ? 1 : o,\n      c = n.min,\n      s = void 0 === c ? \"auto\" : c,\n      d = n.max,\n      f = void 0 === d ? \"auto\" : d,\n      l = n.reverse,\n      v = void 0 !== l && l;\n    a = \"auto\" === s ? t.min : s, i = \"auto\" === f ? t.max : f;\n    var y = m().constant(u).rangeRound(\"x\" === e ? [0, r] : [r, 0]).nice();\n    !0 === v ? y.domain([i, a]) : y.domain([a, i]);\n    var p = y;\n    return p.type = \"symlog\", p;\n  },\n  an = function (n) {\n    return \"x\" === n ? \"y\" : \"x\";\n  },\n  on = function (n, t) {\n    return n === t;\n  },\n  un = function (n, t) {\n    return n.getTime() === t.getTime();\n  };\nfunction cn(n, t, r, e) {\n  switch (n.type) {\n    case \"linear\":\n      return W(n, t, r, e);\n    case \"point\":\n      return Y(n, t, r);\n    case \"band\":\n      return _(n, t, r, e);\n    case \"time\":\n      return tn(n, t, r);\n    case \"log\":\n      return rn(n, t, r, e);\n    case \"symlog\":\n      return en(n, t, r, e);\n    default:\n      throw new Error(\"invalid scale spec\");\n  }\n}\nvar sn = function (n, t, r) {\n    var e;\n    if (\"stacked\" in r && r.stacked) {\n      var a = n.data[\"x\" === t ? \"xStacked\" : \"yStacked\"];\n      return null == a ? null : r(a);\n    }\n    return null != (e = r(n.data[t])) ? e : null;\n  },\n  dn = function (n, t, r, e, a) {\n    var i = n.map(function (n) {\n        return function (n) {\n          return $({}, n, {\n            data: n.data.map(function (n) {\n              return {\n                data: $({}, n)\n              };\n            })\n          });\n        }(n);\n      }),\n      o = fn(i, t, r);\n    \"stacked\" in t && !0 === t.stacked && vn(o, i), \"stacked\" in r && !0 === r.stacked && yn(o, i);\n    var u = cn(t, o.x, e, \"x\"),\n      c = cn(r, o.y, a, \"y\"),\n      s = i.map(function (n) {\n        return $({}, n, {\n          data: n.data.map(function (n) {\n            return $({}, n, {\n              position: {\n                x: sn(n, \"x\", u),\n                y: sn(n, \"y\", c)\n              }\n            });\n          })\n        });\n      });\n    return $({}, o, {\n      series: s,\n      xScale: u,\n      yScale: c\n    });\n  },\n  fn = function (n, t, r) {\n    return {\n      x: ln(n, \"x\", t),\n      y: ln(n, \"y\", r)\n    };\n  },\n  ln = function (a, i, o, u) {\n    var c = void 0 === u ? {} : u,\n      s = c.getValue,\n      d = void 0 === s ? function (n) {\n        return n.data[i];\n      } : s,\n      f = c.setValue,\n      l = void 0 === f ? function (n, t) {\n        n.data[i] = t;\n      } : f;\n    if (\"linear\" === o.type) a.forEach(function (n) {\n      n.data.forEach(function (n) {\n        var t = d(n);\n        t && l(n, parseFloat(String(t)));\n      });\n    });else if (\"time\" === o.type && \"native\" !== o.format) {\n      var m = Q(o);\n      a.forEach(function (n) {\n        n.data.forEach(function (n) {\n          var t = d(n);\n          t && l(n, m(t));\n        });\n      });\n    }\n    var v = [];\n    switch (a.forEach(function (n) {\n      n.data.forEach(function (n) {\n        v.push(d(n));\n      });\n    }), o.type) {\n      case \"linear\":\n        var y = r(n(v).filter(function (n) {\n          return null !== n;\n        }), function (n) {\n          return n;\n        });\n        return {\n          all: y,\n          min: Math.min.apply(Math, y),\n          max: Math.max.apply(Math, y)\n        };\n      case \"time\":\n        var p = t(v, function (n) {\n          return n.getTime();\n        }).slice(0).sort(function (n, t) {\n          return t.getTime() - n.getTime();\n        }).reverse();\n        return {\n          all: p,\n          min: p[0],\n          max: e(p)\n        };\n      default:\n        var h = n(v);\n        return {\n          all: h,\n          min: h[0],\n          max: e(h)\n        };\n    }\n  },\n  mn = function (n, t, r) {\n    var i = an(n),\n      o = [];\n    t[i].all.forEach(function (t) {\n      var u = a(t) ? un : on,\n        c = [];\n      r.forEach(function (r) {\n        var a = r.data.find(function (n) {\n            return u(n.data[i], t);\n          }),\n          s = null,\n          d = null;\n        if (void 0 !== a) {\n          if (null !== (s = a.data[n])) {\n            var f = e(c);\n            void 0 === f ? d = s : null !== f && (d = f + s);\n          }\n          a.data[\"x\" === n ? \"xStacked\" : \"yStacked\"] = d;\n        }\n        c.push(d), null !== d && o.push(d);\n      });\n    }), t[n].minStacked = Math.min.apply(Math, o), t[n].maxStacked = Math.max.apply(Math, o);\n  },\n  vn = function (n, t) {\n    return mn(\"x\", n, t);\n  },\n  yn = function (n, t) {\n    return mn(\"y\", n, t);\n  },\n  pn = function (n) {\n    var t = n.bandwidth();\n    if (0 === t) return n;\n    var r = t / 2;\n    return n.round() && (r = Math.round(r)), function (t) {\n      var e;\n      return (null != (e = n(t)) ? e : 0) + r;\n    };\n  },\n  hn = {\n    millisecond: [y, p],\n    second: [h, g],\n    minute: [x, k],\n    hour: [T, b],\n    day: [v(function (n) {\n      return n.setHours(0, 0, 0, 0);\n    }, function (n, t) {\n      return n.setDate(n.getDate() + t);\n    }, function (n, t) {\n      return (t.getTime() - n.getTime()) / 864e5;\n    }, function (n) {\n      return Math.floor(n.getTime() / 864e5);\n    }), v(function (n) {\n      return n.setUTCHours(0, 0, 0, 0);\n    }, function (n, t) {\n      return n.setUTCDate(n.getUTCDate() + t);\n    }, function (n, t) {\n      return (t.getTime() - n.getTime()) / 864e5;\n    }, function (n) {\n      return Math.floor(n.getTime() / 864e5);\n    })],\n    week: [M, w],\n    sunday: [E, S],\n    monday: [D, C],\n    tuesday: [U, j],\n    wednesday: [O, R],\n    thursday: [H, V],\n    friday: [q, A],\n    saturday: [B, F],\n    month: [N, z],\n    year: [I, P]\n  },\n  gn = Object.keys(hn),\n  xn = new RegExp(\"^every\\\\s*(\\\\d+)?\\\\s*(\" + gn.join(\"|\") + \")s?$\", \"i\"),\n  kn = function (n, t) {\n    if (Array.isArray(t)) return t;\n    if (\"string\" == typeof t && \"useUTC\" in n) {\n      var r = t.match(xn);\n      if (r) {\n        var e = r[1],\n          a = r[2],\n          i = hn[a][n.useUTC ? 1 : 0];\n        if (\"day\" === a) {\n          var o,\n            u,\n            c = n.domain(),\n            s = c[0],\n            d = c[1],\n            f = new Date(d);\n          return f.setDate(f.getDate() + 1), null != (o = null == (u = i.every(Number(null != e ? e : 1))) ? void 0 : u.range(s, f)) ? o : [];\n        }\n        if (void 0 === e) return n.ticks(i);\n        var l = i.every(Number(e));\n        if (l) return n.ticks(l);\n      }\n      throw new Error(\"Invalid tickValues: \" + t);\n    }\n    if (\"ticks\" in n) {\n      if (void 0 === t) return n.ticks();\n      if (\"number\" == typeof (m = t) && isFinite(m) && Math.floor(m) === m) return n.ticks(t);\n    }\n    var m;\n    return n.domain();\n  };\nexport { nn as castBandScale, X as castLinearScale, Z as castPointScale, pn as centerScale, un as compareDateValues, on as compareValues, cn as computeScale, dn as computeXYScalesForSeries, _ as createBandScale, Q as createDateNormalizer, W as createLinearScale, rn as createLogScale, Y as createPointScale, L as createPrecisionMethod, en as createSymlogScale, tn as createTimeScale, ln as generateSeriesAxis, fn as generateSeriesXY, an as getOtherAxis, kn as getScaleTicks, J as precisionCutOffs, K as precisionCutOffsByType, mn as stackAxis, G as timePrecisions };\n//# sourceMappingURL=nivo-scales.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}