package com.muratcan.yeldan.mavenanalyzer.service.impl;

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class VulnerabilityCheckerImpl {

    @Async
    @Override
    public void scheduleVulnerabilityChecks(DependencyAnalysis analysis, List<Dependency> dependencies) {
        // Do not proceed if vulnerability checking is not enabled or already completed
        if (analysis.getVulnerabilityCheckStatus() == VulnerabilityCheckStatus.NOT_STARTED ||
                analysis.getVulnerabilityCheckStatus() == VulnerabilityCheckStatus.COMPLETED) {
            log.info("Skipping vulnerability scan for analysis ID: {} - Current status: {}",
                    analysis.getId(), analysis.getVulnerabilityCheckStatus());
            return;
        }

        log.info("Starting vulnerability scan for analysis ID: {}, Dependencies: {}", analysis.getId(), dependencies.size());

        AppSettings settings = appSettingsRepository.findFirstByOrderByIdAsc();
        int delay = settings.getVulnerabilityCheckDelay();

        try {
            int batchSize = 10;
            int totalDependencies = dependencies.size();
            int completedChecks = 0;

            for (int i = 0; i < totalDependencies; i += batchSize) {
                int endIndex = Math.min(i + batchSize, totalDependencies);
                List<Dependency> batch = dependencies.subList(i, endIndex);

                log.debug("Processing dependency batch {}/{} for analysis ID: {}",
                        (i / batchSize) + 1, (int) Math.ceil((double) totalDependencies / batchSize), analysis.getId());

                // Process each dependency in the batch
                for (Dependency dependency : batch) {
                    try {
                        checkVulnerabilities(dependency);
                        completedChecks++;
                    } catch (Exception e) {
                        log.error("Error checking vulnerabilities for dependency: {}:{}:{}",
                                dependency.getGroupId(), dependency.getArtifactId(), dependency.getCurrentVersion(), e);
                    }

                    // Add a delay between API calls to avoid rate limiting
                    if (delay > 0 && completedChecks < totalDependencies) {
                        Thread.sleep(delay);
                    }
                }
            }

            // Update vulnerability check status to COMPLETED
            analysis.setVulnerabilityCheckStatus(VulnerabilityCheckStatus.COMPLETED);
            dependencyAnalysisRepository.save(analysis);

            log.info("Completed vulnerability scan for analysis ID: {}, Scanned {} dependencies",
                    analysis.getId(), completedChecks);

            // Send completion notification if enabled
            if (analysis.isNotifyOnCompletion()) {
                sendCompletionNotification(analysis);
            }

        } catch (Exception e) {
            log.error("Error during vulnerability scan for analysis ID: {}", analysis.getId(), e);
            // Set status to ERROR if something goes wrong
            analysis.setVulnerabilityCheckStatus(VulnerabilityCheckStatus.ERROR);
            dependencyAnalysisRepository.save(analysis);
        }
    }

    /**
     * Sends a notification that the analysis is complete
     */
    private void sendCompletionNotification(DependencyAnalysis analysis) {
        // Check if global notifications are enabled
        AppSettings settings = appSettingsRepository.findFirstByOrderByIdAsc();
        if (!settings.getShowNotifications()) {
            log.debug("Notifications are disabled globally, skipping completion notification for analysis ID: {}", analysis.getId());
            return;
        }

        log.info("Sending analysis completion notification for analysis ID: {}", analysis.getId());

        Project project = analysis.getProject();
        String projectName = project != null ? project.getName() : "Standalone Analysis";

        // Count vulnerable dependencies
        long vulnerableCount = analysis.getDependencies().stream()
                .filter(d -> d.getVulnerabilities() != null && !d.getVulnerabilities().isEmpty())
                .count();

        // Create notification message
        String notificationMessage = String.format(
                "Analysis completed for %s. Found %d dependencies (%d outdated, %d vulnerable).",
                projectName,
                analysis.getTotalDependencies(),
                analysis.getOutdatedDependencies(),
                vulnerableCount
        );

        // In a real implementation, this would send a system notification, email, or push notification
        // For demo purposes, we'll just log it
        log.info("NOTIFICATION: {}", notificationMessage);

        // If you had a notification service, you would inject and call it here:
        // notificationService.sendNotification(analysis.getProject(), "Analysis Complete", notificationMessage);
    }
} 