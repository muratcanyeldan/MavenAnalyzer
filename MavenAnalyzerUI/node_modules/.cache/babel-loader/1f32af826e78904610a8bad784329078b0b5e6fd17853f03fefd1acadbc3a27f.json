{"ast":null,"code":"import * as t from \"react\";\nimport { memo as e, useMemo as i, useCallback as n, createElement as r } from \"react\";\nimport { textPropsByEngine as a, useTheme as o, sanitizeSvgTextStyle as l, useMotionConfig as s, degreesToRadians as c } from \"@nivo/core\";\nimport { animated as f, useSpring as u, useTransition as d } from \"@react-spring/web\";\nimport { timeFormat as x } from \"d3-time-format\";\nimport { format as m } from \"d3-format\";\nimport { getScaleTicks as y, centerScale as h } from \"@nivo/scales\";\nimport { jsxs as k, jsx as g, Fragment as v } from \"react/jsx-runtime\";\nfunction p() {\n  return p = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = arguments[e];\n      for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);\n    }\n    return t;\n  }, p.apply(this, arguments);\n}\nvar b = function (t) {\n    var e,\n      i = t.axis,\n      n = t.scale,\n      r = t.ticksPosition,\n      o = t.tickValues,\n      l = t.tickSize,\n      s = t.tickPadding,\n      c = t.tickRotation,\n      f = t.truncateTickAt,\n      u = t.engine,\n      d = void 0 === u ? \"svg\" : u,\n      x = y(n, o),\n      m = a[d],\n      k = \"bandwidth\" in n ? h(n) : n,\n      g = {\n        lineX: 0,\n        lineY: 0\n      },\n      v = {\n        textX: 0,\n        textY: 0\n      },\n      b = \"object\" == typeof document && \"rtl\" === document.dir,\n      P = m.align.center,\n      T = m.baseline.center;\n    \"x\" === i ? (e = function (t) {\n      var e;\n      return {\n        x: null != (e = k(t)) ? e : 0,\n        y: 0\n      };\n    }, g.lineY = l * (\"after\" === r ? 1 : -1), v.textY = (l + s) * (\"after\" === r ? 1 : -1), T = \"after\" === r ? m.baseline.top : m.baseline.bottom, 0 === c ? P = m.align.center : \"after\" === r && c < 0 || \"before\" === r && c > 0 ? (P = m.align[b ? \"left\" : \"right\"], T = m.baseline.center) : (\"after\" === r && c > 0 || \"before\" === r && c < 0) && (P = m.align[b ? \"right\" : \"left\"], T = m.baseline.center)) : (e = function (t) {\n      var e;\n      return {\n        x: 0,\n        y: null != (e = k(t)) ? e : 0\n      };\n    }, g.lineX = l * (\"after\" === r ? 1 : -1), v.textX = (l + s) * (\"after\" === r ? 1 : -1), P = \"after\" === r ? m.align.left : m.align.right);\n    return {\n      ticks: x.map(function (t) {\n        var i = \"string\" == typeof t ? function (t) {\n          var e = String(t).length;\n          return f && f > 0 && e > f ? \"\" + String(t).slice(0, f).concat(\"...\") : \"\" + t;\n        }(t) : t;\n        return p({\n          key: t instanceof Date ? \"\" + t.valueOf() : \"\" + t,\n          value: i\n        }, e(t), g, v);\n      }),\n      textAlign: P,\n      textBaseline: T\n    };\n  },\n  P = function (t, e) {\n    if (void 0 === t || \"function\" == typeof t) return t;\n    if (\"time\" === e.type) {\n      var i = x(t);\n      return function (t) {\n        return i(t instanceof Date ? t : new Date(t));\n      };\n    }\n    return m(t);\n  },\n  T = function (t) {\n    var e,\n      i = t.width,\n      n = t.height,\n      r = t.scale,\n      a = t.axis,\n      o = t.values,\n      l = (e = o, Array.isArray(e) ? o : void 0) || y(r, o),\n      s = \"bandwidth\" in r ? h(r) : r,\n      c = \"x\" === a ? l.map(function (t) {\n        var e, i;\n        return {\n          key: t instanceof Date ? \"\" + t.valueOf() : \"\" + t,\n          x1: null != (e = s(t)) ? e : 0,\n          x2: null != (i = s(t)) ? i : 0,\n          y1: 0,\n          y2: n\n        };\n      }) : l.map(function (t) {\n        var e, n;\n        return {\n          key: t instanceof Date ? \"\" + t.valueOf() : \"\" + t,\n          x1: 0,\n          x2: i,\n          y1: null != (e = s(t)) ? e : 0,\n          y2: null != (n = s(t)) ? n : 0\n        };\n      });\n    return c;\n  },\n  A = e(function (t) {\n    var e,\n      n = t.value,\n      r = t.format,\n      a = t.lineX,\n      s = t.lineY,\n      c = t.onClick,\n      u = t.textBaseline,\n      d = t.textAnchor,\n      x = t.animatedProps,\n      m = o(),\n      y = m.axis.ticks.line,\n      h = m.axis.ticks.text,\n      v = null != (e = null == r ? void 0 : r(n)) ? e : n,\n      b = i(function () {\n        var t = {\n          opacity: x.opacity\n        };\n        return c ? {\n          style: p({}, t, {\n            cursor: \"pointer\"\n          }),\n          onClick: function (t) {\n            return c(t, v);\n          }\n        } : {\n          style: t\n        };\n      }, [x.opacity, c, v]);\n    return k(f.g, p({\n      transform: x.transform\n    }, b, {\n      children: [g(\"line\", {\n        x1: 0,\n        x2: a,\n        y1: 0,\n        y2: s,\n        style: y\n      }), h.outlineWidth > 0 && g(f.text, {\n        dominantBaseline: u,\n        textAnchor: d,\n        transform: x.textTransform,\n        style: h,\n        strokeWidth: 2 * h.outlineWidth,\n        stroke: h.outlineColor,\n        strokeLinejoin: \"round\",\n        children: \"\" + v\n      }), g(f.text, {\n        dominantBaseline: u,\n        textAnchor: d,\n        transform: x.textTransform,\n        style: l(h),\n        children: \"\" + v\n      })]\n    }));\n  }),\n  S = function (e) {\n    var r = e.axis,\n      a = e.scale,\n      l = e.x,\n      c = void 0 === l ? 0 : l,\n      x = e.y,\n      m = void 0 === x ? 0 : x,\n      y = e.length,\n      h = e.ticksPosition,\n      T = e.tickValues,\n      S = e.tickSize,\n      W = void 0 === S ? 5 : S,\n      w = e.tickPadding,\n      B = void 0 === w ? 5 : w,\n      X = e.tickRotation,\n      Y = void 0 === X ? 0 : X,\n      C = e.format,\n      O = e.renderTick,\n      j = void 0 === O ? A : O,\n      z = e.truncateTickAt,\n      V = e.legend,\n      D = e.legendPosition,\n      R = void 0 === D ? \"end\" : D,\n      E = e.legendOffset,\n      q = void 0 === E ? 0 : E,\n      F = e.onClick,\n      L = e.ariaHidden,\n      N = o(),\n      H = N.axis.legend.text,\n      I = i(function () {\n        return P(C, a);\n      }, [C, a]),\n      J = b({\n        axis: r,\n        scale: a,\n        ticksPosition: h,\n        tickValues: T,\n        tickSize: W,\n        tickPadding: B,\n        tickRotation: Y,\n        truncateTickAt: z\n      }),\n      G = J.ticks,\n      K = J.textAlign,\n      M = J.textBaseline,\n      Q = null;\n    if (void 0 !== V) {\n      var U,\n        Z = 0,\n        $ = 0,\n        _ = 0;\n      \"y\" === r ? (_ = -90, Z = q, \"start\" === R ? (U = \"start\", $ = y) : \"middle\" === R ? (U = \"middle\", $ = y / 2) : \"end\" === R && (U = \"end\")) : ($ = q, \"start\" === R ? U = \"start\" : \"middle\" === R ? (U = \"middle\", Z = y / 2) : \"end\" === R && (U = \"end\", Z = y)), Q = k(v, {\n        children: [H.outlineWidth > 0 && g(\"text\", {\n          transform: \"translate(\" + Z + \", \" + $ + \") rotate(\" + _ + \")\",\n          textAnchor: U,\n          style: p({\n            dominantBaseline: \"central\"\n          }, H),\n          strokeWidth: 2 * H.outlineWidth,\n          stroke: H.outlineColor,\n          strokeLinejoin: \"round\",\n          children: V\n        }), g(\"text\", {\n          transform: \"translate(\" + Z + \", \" + $ + \") rotate(\" + _ + \")\",\n          textAnchor: U,\n          style: p({\n            dominantBaseline: \"central\"\n          }, H),\n          children: V\n        })]\n      });\n    }\n    var tt = s(),\n      et = tt.animate,\n      it = tt.config,\n      nt = u({\n        transform: \"translate(\" + c + \",\" + m + \")\",\n        lineX2: \"x\" === r ? y : 0,\n        lineY2: \"x\" === r ? 0 : y,\n        config: it,\n        immediate: !et\n      }),\n      rt = n(function (t) {\n        return {\n          opacity: 1,\n          transform: \"translate(\" + t.x + \",\" + t.y + \")\",\n          textTransform: \"translate(\" + t.textX + \",\" + t.textY + \") rotate(\" + Y + \")\"\n        };\n      }, [Y]),\n      at = n(function (t) {\n        return {\n          opacity: 0,\n          transform: \"translate(\" + t.x + \",\" + t.y + \")\",\n          textTransform: \"translate(\" + t.textX + \",\" + t.textY + \") rotate(\" + Y + \")\"\n        };\n      }, [Y]),\n      ot = d(G, {\n        keys: function (t) {\n          return t.key;\n        },\n        initial: rt,\n        from: at,\n        enter: rt,\n        update: rt,\n        leave: {\n          opacity: 0\n        },\n        config: it,\n        immediate: !et\n      });\n    return k(f.g, {\n      transform: nt.transform,\n      \"aria-hidden\": L,\n      children: [ot(function (e, i, n, r) {\n        return t.createElement(j, p({\n          tickIndex: r,\n          format: I,\n          rotate: Y,\n          textBaseline: M,\n          textAnchor: K,\n          truncateTickAt: z,\n          animatedProps: e\n        }, i, F ? {\n          onClick: F\n        } : {}));\n      }), g(f.line, {\n        style: N.axis.domain.line,\n        x1: 0,\n        x2: nt.lineX2,\n        y1: 0,\n        y2: nt.lineY2\n      }), Q]\n    });\n  },\n  W = e(S),\n  w = [\"top\", \"right\", \"bottom\", \"left\"],\n  B = e(function (t) {\n    var e = t.xScale,\n      i = t.yScale,\n      n = t.width,\n      r = t.height,\n      a = {\n        top: t.top,\n        right: t.right,\n        bottom: t.bottom,\n        left: t.left\n      };\n    return g(v, {\n      children: w.map(function (t) {\n        var o = a[t];\n        if (!o) return null;\n        var l = \"top\" === t || \"bottom\" === t;\n        return g(W, p({}, o, {\n          axis: l ? \"x\" : \"y\",\n          x: \"right\" === t ? n : 0,\n          y: \"bottom\" === t ? r : 0,\n          scale: l ? e : i,\n          length: l ? n : r,\n          ticksPosition: \"top\" === t || \"left\" === t ? \"before\" : \"after\",\n          truncateTickAt: o.truncateTickAt\n        }), t);\n      })\n    });\n  }),\n  X = e(function (t) {\n    var e = t.animatedProps,\n      i = o();\n    return g(f.line, p({}, e, i.grid.line));\n  }),\n  Y = e(function (t) {\n    var e = t.lines,\n      i = s(),\n      n = i.animate,\n      a = i.config,\n      o = d(e, {\n        keys: function (t) {\n          return t.key;\n        },\n        initial: function (t) {\n          return {\n            opacity: 1,\n            x1: t.x1,\n            x2: t.x2,\n            y1: t.y1,\n            y2: t.y2\n          };\n        },\n        from: function (t) {\n          return {\n            opacity: 0,\n            x1: t.x1,\n            x2: t.x2,\n            y1: t.y1,\n            y2: t.y2\n          };\n        },\n        enter: function (t) {\n          return {\n            opacity: 1,\n            x1: t.x1,\n            x2: t.x2,\n            y1: t.y1,\n            y2: t.y2\n          };\n        },\n        update: function (t) {\n          return {\n            opacity: 1,\n            x1: t.x1,\n            x2: t.x2,\n            y1: t.y1,\n            y2: t.y2\n          };\n        },\n        leave: {\n          opacity: 0\n        },\n        config: a,\n        immediate: !n\n      });\n    return g(\"g\", {\n      children: o(function (t, e) {\n        return r(X, p({}, e, {\n          key: e.key,\n          animatedProps: t\n        }));\n      })\n    });\n  }),\n  C = e(function (t) {\n    var e = t.width,\n      n = t.height,\n      r = t.xScale,\n      a = t.yScale,\n      o = t.xValues,\n      l = t.yValues,\n      s = i(function () {\n        return !!r && T({\n          width: e,\n          height: n,\n          scale: r,\n          axis: \"x\",\n          values: o\n        });\n      }, [r, o, e, n]),\n      c = i(function () {\n        return !!a && T({\n          width: e,\n          height: n,\n          scale: a,\n          axis: \"y\",\n          values: l\n        });\n      }, [n, e, a, l]);\n    return k(v, {\n      children: [s && g(Y, {\n        lines: s\n      }), c && g(Y, {\n        lines: c\n      })]\n    });\n  }),\n  O = function (t, e) {\n    var i,\n      n = e.axis,\n      r = e.scale,\n      a = e.x,\n      o = void 0 === a ? 0 : a,\n      l = e.y,\n      s = void 0 === l ? 0 : l,\n      f = e.length,\n      u = e.ticksPosition,\n      d = e.tickValues,\n      x = e.tickSize,\n      m = void 0 === x ? 5 : x,\n      y = e.tickPadding,\n      h = void 0 === y ? 5 : y,\n      k = e.tickRotation,\n      g = void 0 === k ? 0 : k,\n      v = e.format,\n      p = e.legend,\n      P = e.legendPosition,\n      T = void 0 === P ? \"end\" : P,\n      A = e.legendOffset,\n      S = void 0 === A ? 0 : A,\n      W = e.theme,\n      w = b({\n        axis: n,\n        scale: r,\n        ticksPosition: u,\n        tickValues: d,\n        tickSize: m,\n        tickPadding: h,\n        tickRotation: g,\n        engine: \"canvas\"\n      }),\n      B = w.ticks,\n      X = w.textAlign,\n      Y = w.textBaseline;\n    t.save(), t.translate(o, s), t.textAlign = X, t.textBaseline = Y;\n    var C = W.axis.ticks.text;\n    t.font = (C.fontWeight ? C.fontWeight + \" \" : \"\") + C.fontSize + \"px \" + C.fontFamily, (null != (i = W.axis.domain.line.strokeWidth) ? i : 0) > 0 && (t.lineWidth = Number(W.axis.domain.line.strokeWidth), t.lineCap = \"square\", W.axis.domain.line.stroke && (t.strokeStyle = W.axis.domain.line.stroke), t.beginPath(), t.moveTo(0, 0), t.lineTo(\"x\" === n ? f : 0, \"x\" === n ? 0 : f), t.stroke());\n    var O = \"function\" == typeof v ? v : function (t) {\n      return \"\" + t;\n    };\n    if (B.forEach(function (e) {\n      var i;\n      (null != (i = W.axis.ticks.line.strokeWidth) ? i : 0) > 0 && (t.lineWidth = Number(W.axis.ticks.line.strokeWidth), t.lineCap = \"square\", W.axis.ticks.line.stroke && (t.strokeStyle = W.axis.ticks.line.stroke), t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(e.x + e.lineX, e.y + e.lineY), t.stroke());\n      var n = O(e.value);\n      t.save(), t.translate(e.x + e.textX, e.y + e.textY), t.rotate(c(g)), C.outlineWidth > 0 && (t.strokeStyle = C.outlineColor, t.lineWidth = 2 * C.outlineWidth, t.lineJoin = \"round\", t.strokeText(\"\" + n, 0, 0)), W.axis.ticks.text.fill && (t.fillStyle = C.fill), t.fillText(\"\" + n, 0, 0), t.restore();\n    }), void 0 !== p) {\n      var j = 0,\n        z = 0,\n        V = 0,\n        D = \"center\";\n      \"y\" === n ? (V = -90, j = S, \"start\" === T ? (D = \"start\", z = f) : \"middle\" === T ? (D = \"center\", z = f / 2) : \"end\" === T && (D = \"end\")) : (z = S, \"start\" === T ? D = \"start\" : \"middle\" === T ? (D = \"center\", j = f / 2) : \"end\" === T && (D = \"end\", j = f)), t.translate(j, z), t.rotate(c(V)), t.font = (W.axis.legend.text.fontWeight ? W.axis.legend.text.fontWeight + \" \" : \"\") + W.axis.legend.text.fontSize + \"px \" + W.axis.legend.text.fontFamily, W.axis.legend.text.fill && (t.fillStyle = W.axis.legend.text.fill), t.textAlign = D, t.textBaseline = \"middle\", t.fillText(p, 0, 0);\n    }\n    t.restore();\n  },\n  j = function (t, e) {\n    var i = e.xScale,\n      n = e.yScale,\n      r = e.width,\n      a = e.height,\n      o = e.top,\n      l = e.right,\n      s = e.bottom,\n      c = e.left,\n      f = e.theme,\n      u = {\n        top: o,\n        right: l,\n        bottom: s,\n        left: c\n      };\n    w.forEach(function (e) {\n      var o = u[e];\n      if (!o) return null;\n      var l = \"top\" === e || \"bottom\" === e,\n        s = \"top\" === e || \"left\" === e ? \"before\" : \"after\",\n        c = l ? i : n,\n        d = P(o.format, c);\n      O(t, p({}, o, {\n        axis: l ? \"x\" : \"y\",\n        x: \"right\" === e ? r : 0,\n        y: \"bottom\" === e ? a : 0,\n        scale: c,\n        format: d,\n        length: l ? r : a,\n        ticksPosition: s,\n        theme: f\n      }));\n    });\n  },\n  z = function (t, e) {\n    var i = e.width,\n      n = e.height,\n      r = e.scale,\n      a = e.axis,\n      o = e.values;\n    T({\n      width: i,\n      height: n,\n      scale: r,\n      axis: a,\n      values: o\n    }).forEach(function (e) {\n      t.beginPath(), t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.stroke();\n    });\n  };\nexport { B as Axes, W as Axis, A as AxisTick, C as Grid, X as GridLine, Y as GridLines, S as NonMemoizedAxis, w as positions, j as renderAxesToCanvas, O as renderAxisToCanvas, z as renderGridLinesToCanvas };\n//# sourceMappingURL=nivo-axes.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}