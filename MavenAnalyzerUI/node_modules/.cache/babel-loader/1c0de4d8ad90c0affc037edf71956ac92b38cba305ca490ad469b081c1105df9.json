{"ast":null,"code":"import { isValidElement as t, useMemo as n, createElement as i } from \"react\";\nimport o from \"lodash/filter\";\nimport e from \"lodash/isNumber\";\nimport a from \"lodash/omit\";\nimport { absoluteAngleDegrees as r, radiansToDegrees as s, positionFromAngle as l, degreesToRadians as u, useTheme as h, useMotionConfig as d, useAnimatedPath as c } from \"@nivo/core\";\nimport { useSpring as f, animated as y } from \"@react-spring/web\";\nimport { jsxs as x, Fragment as m, jsx as p } from \"react/jsx-runtime\";\nfunction g() {\n  return g = Object.assign ? Object.assign.bind() : function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var i = arguments[n];\n      for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);\n    }\n    return t;\n  }, g.apply(this, arguments);\n}\nvar k = {\n    dotSize: 4,\n    noteWidth: 120,\n    noteTextOffset: 8,\n    animate: !0\n  },\n  W = function (n) {\n    var i = typeof n;\n    return t(n) || \"string\" === i || \"function\" === i || \"object\" === i;\n  },\n  v = function (t) {\n    var n = typeof t;\n    return \"string\" === n || \"function\" === n;\n  },\n  b = function (t) {\n    return \"circle\" === t.type;\n  },\n  w = function (t) {\n    return \"dot\" === t.type;\n  },\n  z = function (t) {\n    return \"rect\" === t.type;\n  },\n  P = function (t) {\n    var n = t.data,\n      i = t.annotations,\n      e = t.getPosition,\n      r = t.getDimensions;\n    return i.reduce(function (t, i) {\n      var s = i.offset || 0;\n      return [].concat(t, o(n, i.match).map(function (t) {\n        var n = e(t),\n          o = r(t);\n        return (b(i) || z(i)) && (o.size = o.size + 2 * s, o.width = o.width + 2 * s, o.height = o.height + 2 * s), g({}, a(i, [\"match\", \"offset\"]), n, o, {\n          size: i.size || o.size,\n          datum: t\n        });\n      }));\n    }, []);\n  },\n  C = function (t, n, i, o) {\n    var e = Math.atan2(o - n, i - t);\n    return r(s(e));\n  },\n  O = function (t) {\n    var n,\n      i,\n      o = t.x,\n      a = t.y,\n      r = t.noteX,\n      s = t.noteY,\n      h = t.noteWidth,\n      d = void 0 === h ? k.noteWidth : h,\n      c = t.noteTextOffset,\n      f = void 0 === c ? k.noteTextOffset : c;\n    if (e(r)) n = o + r;else {\n      if (void 0 === r.abs) throw new Error(\"noteX should be either a number or an object containing an 'abs' property\");\n      n = r.abs;\n    }\n    if (e(s)) i = a + s;else {\n      if (void 0 === s.abs) throw new Error(\"noteY should be either a number or an object containing an 'abs' property\");\n      i = s.abs;\n    }\n    var y = o,\n      x = a,\n      m = C(o, a, n, i);\n    if (b(t)) {\n      var p = l(u(m), t.size / 2);\n      y += p.x, x += p.y;\n    }\n    if (z(t)) {\n      var g = Math.round((m + 90) / 45) % 8;\n      0 === g && (x -= t.height / 2), 1 === g && (y += t.width / 2, x -= t.height / 2), 2 === g && (y += t.width / 2), 3 === g && (y += t.width / 2, x += t.height / 2), 4 === g && (x += t.height / 2), 5 === g && (y -= t.width / 2, x += t.height / 2), 6 === g && (y -= t.width / 2), 7 === g && (y -= t.width / 2, x -= t.height / 2);\n    }\n    var W = n,\n      v = n;\n    return (m + 90) % 360 > 180 ? (W -= d, v -= d) : v += d, {\n      points: [[y, x], [n, i], [v, i]],\n      text: [W, i - f],\n      angle: m + 90\n    };\n  },\n  S = function (t) {\n    var i = t.data,\n      o = t.annotations,\n      e = t.getPosition,\n      a = t.getDimensions;\n    return n(function () {\n      return P({\n        data: i,\n        annotations: o,\n        getPosition: e,\n        getDimensions: a\n      });\n    }, [i, o, e, a]);\n  },\n  j = function (t) {\n    var i = t.annotations;\n    return n(function () {\n      return i.map(function (t) {\n        return g({}, t, {\n          computed: O(g({}, t))\n        });\n      });\n    }, [i]);\n  },\n  M = function (t) {\n    return n(function () {\n      return O(t);\n    }, [t]);\n  },\n  T = function (t) {\n    var n = t.datum,\n      o = t.x,\n      e = t.y,\n      r = t.note,\n      s = h(),\n      l = d(),\n      u = l.animate,\n      c = l.config,\n      k = f({\n        x: o,\n        y: e,\n        config: c,\n        immediate: !u\n      });\n    return \"function\" == typeof r ? i(r, {\n      x: o,\n      y: e,\n      datum: n\n    }) : x(m, {\n      children: [s.annotations.text.outlineWidth > 0 && p(y.text, {\n        x: k.x,\n        y: k.y,\n        style: g({}, s.annotations.text, {\n          strokeLinejoin: \"round\",\n          strokeWidth: 2 * s.annotations.text.outlineWidth,\n          stroke: s.annotations.text.outlineColor\n        }),\n        children: r\n      }), p(y.text, {\n        x: k.x,\n        y: k.y,\n        style: a(s.annotations.text, [\"outlineWidth\", \"outlineColor\"]),\n        children: r\n      })]\n    });\n  },\n  E = function (t) {\n    var i = t.points,\n      o = t.isOutline,\n      e = void 0 !== o && o,\n      a = h(),\n      r = n(function () {\n        var t = i[0];\n        return i.slice(1).reduce(function (t, n) {\n          return t + \" L\" + n[0] + \",\" + n[1];\n        }, \"M\" + t[0] + \",\" + t[1]);\n      }, [i]),\n      s = c(r);\n    if (e && a.annotations.link.outlineWidth <= 0) return null;\n    var l = g({}, a.annotations.link);\n    return e && (l.strokeLinecap = \"square\", l.strokeWidth = a.annotations.link.strokeWidth + 2 * a.annotations.link.outlineWidth, l.stroke = a.annotations.link.outlineColor, l.opacity = a.annotations.link.outlineOpacity), p(y.path, {\n      fill: \"none\",\n      d: s,\n      style: l\n    });\n  },\n  I = function (t) {\n    var n = t.x,\n      i = t.y,\n      o = t.size,\n      e = h(),\n      a = d(),\n      r = a.animate,\n      s = a.config,\n      l = f({\n        x: n,\n        y: i,\n        radius: o / 2,\n        config: s,\n        immediate: !r\n      });\n    return x(m, {\n      children: [e.annotations.outline.outlineWidth > 0 && p(y.circle, {\n        cx: l.x,\n        cy: l.y,\n        r: l.radius,\n        style: g({}, e.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: e.annotations.outline.strokeWidth + 2 * e.annotations.outline.outlineWidth,\n          stroke: e.annotations.outline.outlineColor,\n          opacity: e.annotations.outline.outlineOpacity\n        })\n      }), p(y.circle, {\n        cx: l.x,\n        cy: l.y,\n        r: l.radius,\n        style: e.annotations.outline\n      })]\n    });\n  },\n  D = function (t) {\n    var n = t.x,\n      i = t.y,\n      o = t.size,\n      e = void 0 === o ? k.dotSize : o,\n      a = h(),\n      r = d(),\n      s = r.animate,\n      l = r.config,\n      u = f({\n        x: n,\n        y: i,\n        radius: e / 2,\n        config: l,\n        immediate: !s\n      });\n    return x(m, {\n      children: [a.annotations.outline.outlineWidth > 0 && p(y.circle, {\n        cx: u.x,\n        cy: u.y,\n        r: u.radius,\n        style: g({}, a.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: 2 * a.annotations.outline.outlineWidth,\n          stroke: a.annotations.outline.outlineColor,\n          opacity: a.annotations.outline.outlineOpacity\n        })\n      }), p(y.circle, {\n        cx: u.x,\n        cy: u.y,\n        r: u.radius,\n        style: a.annotations.symbol\n      })]\n    });\n  },\n  L = function (t) {\n    var n = t.x,\n      i = t.y,\n      o = t.width,\n      e = t.height,\n      a = t.borderRadius,\n      r = void 0 === a ? 6 : a,\n      s = h(),\n      l = d(),\n      u = l.animate,\n      c = l.config,\n      k = f({\n        x: n - o / 2,\n        y: i - e / 2,\n        width: o,\n        height: e,\n        config: c,\n        immediate: !u\n      });\n    return x(m, {\n      children: [s.annotations.outline.outlineWidth > 0 && p(y.rect, {\n        x: k.x,\n        y: k.y,\n        rx: r,\n        ry: r,\n        width: k.width,\n        height: k.height,\n        style: g({}, s.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: s.annotations.outline.strokeWidth + 2 * s.annotations.outline.outlineWidth,\n          stroke: s.annotations.outline.outlineColor,\n          opacity: s.annotations.outline.outlineOpacity\n        })\n      }), p(y.rect, {\n        x: k.x,\n        y: k.y,\n        rx: r,\n        ry: r,\n        width: k.width,\n        height: k.height,\n        style: s.annotations.outline\n      })]\n    });\n  },\n  R = function (t) {\n    var n = t.datum,\n      i = t.x,\n      o = t.y,\n      e = t.note,\n      a = M(t);\n    if (!W(e)) throw new Error(\"note should be a valid react element\");\n    return x(m, {\n      children: [p(E, {\n        points: a.points,\n        isOutline: !0\n      }), b(t) && p(I, {\n        x: i,\n        y: o,\n        size: t.size\n      }), w(t) && p(D, {\n        x: i,\n        y: o,\n        size: t.size\n      }), z(t) && p(L, {\n        x: i,\n        y: o,\n        width: t.width,\n        height: t.height,\n        borderRadius: t.borderRadius\n      }), p(E, {\n        points: a.points\n      }), p(T, {\n        datum: n,\n        x: a.text[0],\n        y: a.text[1],\n        note: e\n      })]\n    });\n  },\n  q = function (t, n) {\n    n.forEach(function (n, i) {\n      var o = n[0],\n        e = n[1];\n      0 === i ? t.moveTo(o, e) : t.lineTo(o, e);\n    });\n  },\n  J = function (t, n) {\n    var i = n.annotations,\n      o = n.theme;\n    0 !== i.length && (t.save(), i.forEach(function (n) {\n      if (!v(n.note)) throw new Error(\"note is invalid for canvas implementation\");\n      o.annotations.link.outlineWidth > 0 && (t.lineCap = \"square\", t.strokeStyle = o.annotations.link.outlineColor, t.lineWidth = o.annotations.link.strokeWidth + 2 * o.annotations.link.outlineWidth, t.beginPath(), q(t, n.computed.points), t.stroke(), t.lineCap = \"butt\"), b(n) && o.annotations.outline.outlineWidth > 0 && (t.strokeStyle = o.annotations.outline.outlineColor, t.lineWidth = o.annotations.outline.strokeWidth + 2 * o.annotations.outline.outlineWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), w(n) && o.annotations.symbol.outlineWidth > 0 && (t.strokeStyle = o.annotations.symbol.outlineColor, t.lineWidth = 2 * o.annotations.symbol.outlineWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), z(n) && o.annotations.outline.outlineWidth > 0 && (t.strokeStyle = o.annotations.outline.outlineColor, t.lineWidth = o.annotations.outline.strokeWidth + 2 * o.annotations.outline.outlineWidth, t.beginPath(), t.rect(n.x - n.width / 2, n.y - n.height / 2, n.width, n.height), t.stroke()), t.strokeStyle = o.annotations.link.stroke, t.lineWidth = o.annotations.link.strokeWidth, t.beginPath(), q(t, n.computed.points), t.stroke(), b(n) && (t.strokeStyle = o.annotations.outline.stroke, t.lineWidth = o.annotations.outline.strokeWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), w(n) && (t.fillStyle = o.annotations.symbol.fill, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.fill()), z(n) && (t.strokeStyle = o.annotations.outline.stroke, t.lineWidth = o.annotations.outline.strokeWidth, t.beginPath(), t.rect(n.x - n.width / 2, n.y - n.height / 2, n.width, n.height), t.stroke()), \"function\" == typeof n.note ? n.note(t, {\n        datum: n.datum,\n        x: n.computed.text[0],\n        y: n.computed.text[1],\n        theme: o\n      }) : (t.font = o.annotations.text.fontSize + \"px \" + o.annotations.text.fontFamily, t.textAlign = \"left\", t.textBaseline = \"alphabetic\", t.fillStyle = o.annotations.text.fill, t.strokeStyle = o.annotations.text.outlineColor, t.lineWidth = 2 * o.annotations.text.outlineWidth, o.annotations.text.outlineWidth > 0 && (t.lineJoin = \"round\", t.strokeText(n.note, n.computed.text[0], n.computed.text[1]), t.lineJoin = \"miter\"), t.fillText(n.note, n.computed.text[0], n.computed.text[1]));\n    }), t.restore());\n  };\nexport { R as Annotation, P as bindAnnotations, O as computeAnnotation, k as defaultProps, C as getLinkAngle, v as isCanvasNote, b as isCircleAnnotation, w as isDotAnnotation, z as isRectAnnotation, W as isSvgNote, J as renderAnnotationsToCanvas, S as useAnnotations, M as useComputedAnnotation, j as useComputedAnnotations };\n//# sourceMappingURL=nivo-annotations.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}