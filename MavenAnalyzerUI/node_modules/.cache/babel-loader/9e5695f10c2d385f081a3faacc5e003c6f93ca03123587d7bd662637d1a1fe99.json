{"ast":null,"code":"import { Axes as e, Grid as t, renderGridLinesToCanvas as a, renderAxesToCanvas as i } from \"@nivo/axes\";\nimport { useTheme as n, getPropertyAccessor as l, usePropertyAccessor as r, useValueFormatter as o, Container as d, useMotionConfig as u, useDimensions as c, bindDefs as s, CartesianMarkers as h, SvgWrapper as f, getRelativeCursor as b, isCursorInRect as v, ResponsiveWrapper as g } from \"@nivo/core\";\nimport { animated as m, to as p, useTransition as x } from \"@react-spring/web\";\nimport { useMemo as y, createElement as S, useCallback as k, useState as w, Fragment as L, forwardRef as C, useRef as V, useEffect as M } from \"react\";\nimport { useAnnotations as W, Annotation as T, useComputedAnnotations as B, renderAnnotationsToCanvas as O } from \"@nivo/annotations\";\nimport { jsx as I, Fragment as P, jsxs as E } from \"react/jsx-runtime\";\nimport { BoxLegendSvg as H, renderLegendToCanvas as R } from \"@nivo/legends\";\nimport { useOrdinalColorScale as F, useInheritedColor as D } from \"@nivo/colors\";\nimport { useTooltip as A, BasicTooltip as X } from \"@nivo/tooltip\";\nimport { computeScale as Y } from \"@nivo/scales\";\nimport { stack as G, stackOffsetDiverging as z } from \"d3-shape\";\nimport N from \"lodash/uniqBy\";\nfunction j() {\n  return j = Object.assign ? Object.assign.bind() : function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var a = arguments[t];\n      for (var i in a) Object.prototype.hasOwnProperty.call(a, i) && (e[i] = a[i]);\n    }\n    return e;\n  }, j.apply(this, arguments);\n}\nfunction q(e, t) {\n  if (null == e) return {};\n  var a,\n    i,\n    n = {},\n    l = Object.keys(e);\n  for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) >= 0 || (n[a] = e[a]);\n  return n;\n}\nvar K,\n  _ = function (e) {\n    var t = e.bars,\n      a = e.annotations,\n      i = W({\n        data: t,\n        annotations: a,\n        getPosition: function (e) {\n          return {\n            x: e.x + e.width / 2,\n            y: e.y + e.height / 2\n          };\n        },\n        getDimensions: function (e) {\n          var t = e.height,\n            a = e.width;\n          return {\n            width: a,\n            height: t,\n            size: Math.max(a, t)\n          };\n        }\n      });\n    return I(P, {\n      children: i.map(function (e, t) {\n        return I(T, j({}, e), t);\n      })\n    });\n  },\n  J = function (e) {\n    var t = e.width,\n      a = e.height,\n      i = e.legends,\n      n = e.toggleSerie;\n    return I(P, {\n      children: i.map(function (e, i) {\n        var l,\n          r = e[0],\n          o = e[1];\n        return I(H, j({}, r, {\n          containerWidth: t,\n          containerHeight: a,\n          data: null != (l = r.data) ? l : o,\n          toggleSerie: r.toggleSerie && \"keys\" === r.dataFrom ? n : void 0\n        }), i);\n      })\n    });\n  },\n  Q = [\"data\"],\n  U = function (e) {\n    var t,\n      a = e.bar,\n      i = a.data,\n      l = q(a, Q),\n      r = e.style,\n      o = r.borderColor,\n      d = r.color,\n      u = r.height,\n      c = r.labelColor,\n      s = r.labelOpacity,\n      h = r.labelX,\n      f = r.labelY,\n      b = r.transform,\n      v = r.width,\n      g = r.textAnchor,\n      x = e.borderRadius,\n      w = e.borderWidth,\n      L = e.label,\n      C = e.shouldRenderLabel,\n      V = e.isInteractive,\n      M = e.onClick,\n      W = e.onMouseEnter,\n      T = e.onMouseLeave,\n      B = e.tooltip,\n      O = e.isFocusable,\n      P = e.ariaLabel,\n      H = e.ariaLabelledBy,\n      R = e.ariaDescribedBy,\n      F = e.ariaDisabled,\n      D = e.ariaHidden,\n      X = n(),\n      Y = A(),\n      G = Y.showTooltipFromEvent,\n      z = Y.showTooltipAt,\n      N = Y.hideTooltip,\n      K = y(function () {\n        return function () {\n          return S(B, j({}, l, i));\n        };\n      }, [B, l, i]),\n      _ = k(function (e) {\n        null == M || M(j({\n          color: l.color\n        }, i), e);\n      }, [l, i, M]),\n      J = k(function (e) {\n        return G(K(), e);\n      }, [G, K]),\n      U = k(function (e) {\n        null == W || W(i, e), G(K(), e);\n      }, [i, W, G, K]),\n      Z = k(function (e) {\n        null == T || T(i, e), N();\n      }, [i, N, T]),\n      $ = k(function () {\n        z(K(), [l.absX + l.width / 2, l.absY]);\n      }, [z, K, l]),\n      ee = k(function () {\n        N();\n      }, [N]);\n    return E(m.g, {\n      transform: b,\n      children: [I(m.rect, {\n        width: p(v, function (e) {\n          return Math.max(e, 0);\n        }),\n        height: p(u, function (e) {\n          return Math.max(e, 0);\n        }),\n        rx: x,\n        ry: x,\n        fill: null != (t = i.fill) ? t : d,\n        strokeWidth: w,\n        stroke: o,\n        focusable: O,\n        tabIndex: O ? 0 : void 0,\n        \"aria-label\": P ? P(i) : void 0,\n        \"aria-labelledby\": H ? H(i) : void 0,\n        \"aria-describedby\": R ? R(i) : void 0,\n        \"aria-disabled\": F ? F(i) : void 0,\n        \"aria-hidden\": D ? D(i) : void 0,\n        onMouseEnter: V ? U : void 0,\n        onMouseMove: V ? J : void 0,\n        onMouseLeave: V ? Z : void 0,\n        onClick: V ? _ : void 0,\n        onFocus: V && O ? $ : void 0,\n        onBlur: V && O ? ee : void 0\n      }), C && I(m.text, {\n        x: h,\n        y: f,\n        textAnchor: g,\n        dominantBaseline: \"central\",\n        fillOpacity: s,\n        style: j({}, X.labels.text, {\n          pointerEvents: \"none\",\n          fill: c\n        }),\n        children: L\n      })]\n    });\n  },\n  Z = [\"color\", \"label\"],\n  $ = function (e) {\n    var t = e.color,\n      a = e.label,\n      i = q(e, Z);\n    return I(X, {\n      id: a,\n      value: i.formattedValue,\n      enableChip: !0,\n      color: t\n    });\n  },\n  ee = {\n    indexBy: \"id\",\n    keys: [\"value\"],\n    groupMode: \"stacked\",\n    layout: \"vertical\",\n    reverse: !1,\n    minValue: \"auto\",\n    maxValue: \"auto\",\n    valueScale: {\n      type: \"linear\"\n    },\n    indexScale: {\n      type: \"band\",\n      round: !0\n    },\n    padding: .1,\n    innerPadding: 0,\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: !1,\n    enableGridY: !0,\n    enableLabel: !0,\n    label: \"formattedValue\",\n    labelPosition: \"middle\",\n    labelOffset: 0,\n    labelSkipWidth: 0,\n    labelSkipHeight: 0,\n    labelTextColor: {\n      from: \"theme\",\n      theme: \"labels.text.fill\"\n    },\n    colorBy: \"id\",\n    colors: {\n      scheme: \"nivo\"\n    },\n    borderRadius: 0,\n    borderWidth: 0,\n    borderColor: {\n      from: \"color\"\n    },\n    isInteractive: !0,\n    tooltip: $,\n    tooltipLabel: function (e) {\n      return e.id + \" - \" + e.indexValue;\n    },\n    legends: [],\n    initialHiddenIds: [],\n    annotations: [],\n    markers: [],\n    enableTotals: !1,\n    totalsOffset: 10\n  },\n  te = j({}, ee, {\n    layers: [\"grid\", \"axes\", \"bars\", \"totals\", \"markers\", \"legends\", \"annotations\"],\n    barComponent: U,\n    defs: [],\n    fill: [],\n    animate: !0,\n    motionConfig: \"default\",\n    role: \"img\",\n    isFocusable: !1\n  }),\n  ae = j({}, ee, {\n    layers: [\"grid\", \"axes\", \"bars\", \"totals\", \"legends\", \"annotations\"],\n    pixelRatio: \"undefined\" != typeof window && null != (K = window.devicePixelRatio) ? K : 1\n  }),\n  ie = function (e, t, a, i, n, l) {\n    return Y(i, {\n      all: e.map(t),\n      min: 0,\n      max: 0\n    }, n, l).padding(a);\n  },\n  ne = function (e, t) {\n    return e.map(function (e) {\n      return j({}, t.reduce(function (e, t) {\n        return e[t] = null, e;\n      }, {}), e);\n    });\n  },\n  le = function (e) {\n    return Object.keys(e).reduce(function (t, a) {\n      return e[a] && (t[a] = e[a]), t;\n    }, {});\n  },\n  re = function (e) {\n    return [e, Number(e)];\n  };\nfunction oe(e, t, a, i) {\n  return void 0 === e && (e = ee.layout), void 0 === t && (t = ee.reverse), void 0 === a && (a = ee.labelPosition), void 0 === i && (i = ee.labelOffset), function (n, l) {\n    var r = i * (t ? -1 : 1);\n    if (\"horizontal\" === e) {\n      var o = n / 2;\n      return \"start\" === a ? o = t ? n : 0 : \"end\" === a && (o = t ? 0 : n), {\n        labelX: o + r,\n        labelY: l / 2,\n        textAnchor: \"middle\" === a ? \"middle\" : t ? \"end\" : \"start\"\n      };\n    }\n    var d = l / 2;\n    return \"start\" === a ? d = t ? 0 : l : \"end\" === a && (d = t ? l : 0), {\n      labelX: n / 2,\n      labelY: d - r,\n      textAnchor: \"middle\"\n    };\n  };\n}\nvar de = [\"layout\", \"minValue\", \"maxValue\", \"reverse\", \"width\", \"height\", \"padding\", \"innerPadding\", \"valueScale\", \"indexScale\", \"hiddenIds\"],\n  ue = function (e, t) {\n    return e > t;\n  },\n  ce = function (e, t) {\n    return e < t;\n  },\n  se = function (e, t) {\n    return Array.from(\" \".repeat(t - e), function (t, a) {\n      return e + a;\n    });\n  },\n  he = function (e) {\n    return ue(e, 0) ? 0 : e;\n  },\n  fe = function (e, t, a, i) {\n    var n = e.data,\n      l = e.formatValue,\n      r = e.getColor,\n      o = e.getIndex,\n      d = e.getTooltipLabel,\n      u = e.innerPadding,\n      c = void 0 === u ? 0 : u,\n      s = e.keys,\n      h = e.xScale,\n      f = e.yScale,\n      b = e.margin,\n      v = a ? ce : ue,\n      g = n.map(le),\n      m = [];\n    return s.forEach(function (e, a) {\n      return se(0, h.domain().length).forEach(function (u) {\n        var s,\n          p,\n          x,\n          y = re(n[u][e]),\n          S = y[0],\n          k = y[1],\n          w = o(n[u]),\n          L = (null != (s = h(w)) ? s : 0) + t * a + c * a,\n          C = v(p = k, 0) ? null != (x = f(p)) ? x : 0 : i,\n          V = function (e, t) {\n            var a;\n            return v(e, 0) ? i - t : (null != (a = f(e)) ? a : 0) - i;\n          }(k, C),\n          M = {\n            id: e,\n            value: null === S ? S : k,\n            formattedValue: l(k),\n            hidden: !1,\n            index: u,\n            indexValue: w,\n            data: g[u]\n          };\n        m.push({\n          key: e + \".\" + M.indexValue,\n          index: m.length,\n          data: M,\n          x: L,\n          y: C,\n          absX: b.left + L,\n          absY: b.top + C,\n          width: t,\n          height: V,\n          color: r(M),\n          label: d(M)\n        });\n      });\n    }), m;\n  },\n  be = function (e, t, a, i) {\n    var n = e.data,\n      l = e.formatValue,\n      r = e.getIndex,\n      o = e.getColor,\n      d = e.getTooltipLabel,\n      u = e.keys,\n      c = e.innerPadding,\n      s = void 0 === c ? 0 : c,\n      h = e.xScale,\n      f = e.yScale,\n      b = e.margin,\n      v = a ? ce : ue,\n      g = n.map(le),\n      m = [];\n    return u.forEach(function (e, a) {\n      return se(0, f.domain().length).forEach(function (u) {\n        var c,\n          p,\n          x,\n          y = re(n[u][e]),\n          S = y[0],\n          k = y[1],\n          w = r(n[u]),\n          L = v(p = k, 0) ? i : null != (x = h(p)) ? x : 0,\n          C = (null != (c = f(w)) ? c : 0) + t * a + s * a,\n          V = function (e, t) {\n            var a;\n            return v(e, 0) ? (null != (a = h(e)) ? a : 0) - i : i - t;\n          }(k, L),\n          M = {\n            id: e,\n            value: null === S ? S : k,\n            formattedValue: l(k),\n            hidden: !1,\n            index: u,\n            indexValue: w,\n            data: g[u]\n          };\n        m.push({\n          key: e + \".\" + M.indexValue,\n          index: m.length,\n          data: M,\n          x: L,\n          y: C,\n          absX: b.left + L,\n          absY: b.top + C,\n          width: V,\n          height: t,\n          color: o(M),\n          label: d(M)\n        });\n      });\n    }), m;\n  },\n  ve = function (e) {\n    var t,\n      a,\n      i = e.layout,\n      n = e.minValue,\n      l = e.maxValue,\n      r = e.reverse,\n      o = e.width,\n      d = e.height,\n      u = e.padding,\n      c = void 0 === u ? 0 : u,\n      s = e.innerPadding,\n      h = void 0 === s ? 0 : s,\n      f = e.valueScale,\n      b = e.indexScale,\n      v = e.hiddenIds,\n      g = void 0 === v ? [] : v,\n      m = q(e, de),\n      p = m.keys.filter(function (e) {\n        return !g.includes(e);\n      }),\n      x = ne(m.data, p),\n      y = \"vertical\" === i ? [\"y\", \"x\", o] : [\"x\", \"y\", d],\n      S = y[0],\n      k = y[1],\n      w = y[2],\n      L = ie(x, m.getIndex, c, b, w, k),\n      C = j({\n        max: l,\n        min: n,\n        reverse: r\n      }, f),\n      V = \"auto\" === C.min ? he : function (e) {\n        return e;\n      },\n      M = x.reduce(function (e, t) {\n        return [].concat(e, p.map(function (e) {\n          return t[e];\n        }));\n      }, []).filter(Boolean),\n      W = V(Math.min.apply(Math, M)),\n      T = (a = Math.max.apply(Math, M), isFinite(a) ? a : 0),\n      B = Y(C, {\n        all: M,\n        min: W,\n        max: T\n      }, \"x\" === S ? o : d, S),\n      O = \"vertical\" === i ? [L, B] : [B, L],\n      I = O[0],\n      P = O[1],\n      E = (L.bandwidth() - h * (p.length - 1)) / p.length,\n      H = [j({}, m, {\n        data: x,\n        keys: p,\n        innerPadding: h,\n        xScale: I,\n        yScale: P\n      }), E, C.reverse, null != (t = B(0)) ? t : 0];\n    return {\n      xScale: I,\n      yScale: P,\n      bars: E > 0 ? \"vertical\" === i ? fe.apply(void 0, H) : be.apply(void 0, H) : []\n    };\n  },\n  ge = [\"data\", \"layout\", \"minValue\", \"maxValue\", \"reverse\", \"width\", \"height\", \"padding\", \"valueScale\", \"indexScale\", \"hiddenIds\"],\n  me = function e(t) {\n    var a;\n    return t.some(Array.isArray) ? e((a = []).concat.apply(a, t)) : t;\n  },\n  pe = function (e, t, a) {\n    var i = e.formatValue,\n      n = e.getColor,\n      l = e.getIndex,\n      r = e.getTooltipLabel,\n      o = e.innerPadding,\n      d = e.stackedData,\n      u = e.xScale,\n      c = e.yScale,\n      s = e.margin,\n      h = [];\n    return d.forEach(function (e) {\n      return u.domain().forEach(function (d, f) {\n        var b,\n          v,\n          g = e[f],\n          m = null != (b = u(l(g.data))) ? b : 0,\n          p = (null != (v = function (e) {\n            return c(e[a ? 0 : 1]);\n          }(g)) ? v : 0) + .5 * o,\n          x = function (e, t) {\n            var i;\n            return (null != (i = c(e[a ? 1 : 0])) ? i : 0) - t;\n          }(g, p) - o,\n          y = re(g.data[e.key]),\n          S = y[0],\n          k = y[1],\n          w = {\n            id: e.key,\n            value: null === S ? S : k,\n            formattedValue: i(k),\n            hidden: !1,\n            index: f,\n            indexValue: d,\n            data: le(g.data)\n          };\n        h.push({\n          key: e.key + \".\" + d,\n          index: h.length,\n          data: w,\n          x: m,\n          y: p,\n          absX: s.left + m,\n          absY: s.top + p,\n          width: t,\n          height: x,\n          color: n(w),\n          label: r(w)\n        });\n      });\n    }), h;\n  },\n  xe = function (e, t, a) {\n    var i = e.formatValue,\n      n = e.getColor,\n      l = e.getIndex,\n      r = e.getTooltipLabel,\n      o = e.innerPadding,\n      d = e.stackedData,\n      u = e.xScale,\n      c = e.yScale,\n      s = e.margin,\n      h = [];\n    return d.forEach(function (e) {\n      return c.domain().forEach(function (d, f) {\n        var b,\n          v,\n          g = e[f],\n          m = null != (b = c(l(g.data))) ? b : 0,\n          p = (null != (v = function (e) {\n            return u(e[a ? 1 : 0]);\n          }(g)) ? v : 0) + .5 * o,\n          x = function (e, t) {\n            var i;\n            return (null != (i = u(e[a ? 0 : 1])) ? i : 0) - t;\n          }(g, p) - o,\n          y = re(g.data[e.key]),\n          S = y[0],\n          k = y[1],\n          w = {\n            id: e.key,\n            value: null === S ? S : k,\n            formattedValue: i(k),\n            hidden: !1,\n            index: f,\n            indexValue: d,\n            data: le(g.data)\n          };\n        h.push({\n          key: e.key + \".\" + d,\n          index: h.length,\n          data: w,\n          x: p,\n          y: m,\n          absX: s.left + p,\n          absY: s.top + m,\n          width: x,\n          height: t,\n          color: n(w),\n          label: r(w)\n        });\n      });\n    }), h;\n  },\n  ye = function (e) {\n    var t,\n      a = e.data,\n      i = e.layout,\n      n = e.minValue,\n      l = e.maxValue,\n      r = e.reverse,\n      o = e.width,\n      d = e.height,\n      u = e.padding,\n      c = void 0 === u ? 0 : u,\n      s = e.valueScale,\n      h = e.indexScale,\n      f = e.hiddenIds,\n      b = void 0 === f ? [] : f,\n      v = q(e, ge),\n      g = v.keys.filter(function (e) {\n        return !b.includes(e);\n      }),\n      m = G().keys(g).offset(z)(ne(a, g)),\n      p = \"vertical\" === i ? [\"y\", \"x\", o] : [\"x\", \"y\", d],\n      x = p[0],\n      y = p[1],\n      S = p[2],\n      k = ie(a, v.getIndex, c, h, S, y),\n      w = j({\n        max: l,\n        min: n,\n        reverse: r\n      }, s),\n      L = (t = me(m), \"log\" === s.type ? t.filter(function (e) {\n        return 0 !== e;\n      }) : t),\n      C = Math.min.apply(Math, L),\n      V = Math.max.apply(Math, L),\n      M = Y(w, {\n        all: L,\n        min: C,\n        max: V\n      }, \"x\" === x ? o : d, x),\n      W = \"vertical\" === i ? [k, M] : [M, k],\n      T = W[0],\n      B = W[1],\n      O = v.innerPadding > 0 ? v.innerPadding : 0,\n      I = k.bandwidth(),\n      P = [j({}, v, {\n        innerPadding: O,\n        stackedData: m,\n        xScale: T,\n        yScale: B\n      }), I, w.reverse];\n    return {\n      xScale: T,\n      yScale: B,\n      bars: I > 0 ? \"vertical\" === i ? pe.apply(void 0, P) : xe.apply(void 0, P) : []\n    };\n  },\n  Se = function (e) {\n    var t = e.bars,\n      a = e.direction,\n      i = e.from,\n      n = e.groupMode,\n      r = e.layout,\n      o = e.legendLabel,\n      d = e.reverse,\n      u = l(null != o ? o : \"indexes\" === i ? \"indexValue\" : \"id\");\n    return \"indexes\" === i ? function (e, t, a) {\n      var i = N(e.map(function (e) {\n        var t, i;\n        return {\n          id: null != (t = e.data.indexValue) ? t : \"\",\n          label: a(e.data),\n          hidden: e.data.hidden,\n          color: null != (i = e.color) ? i : \"#000\"\n        };\n      }), function (e) {\n        return e.id;\n      });\n      return \"horizontal\" === t && i.reverse(), i;\n    }(t, r, u) : function (e, t, a, i, n, l) {\n      var r = N(e.map(function (e) {\n        var t;\n        return {\n          id: e.data.id,\n          label: l(e.data),\n          hidden: e.data.hidden,\n          color: null != (t = e.color) ? t : \"#000\"\n        };\n      }), function (e) {\n        return e.id;\n      });\n      return (\"vertical\" === t && \"stacked\" === i && \"column\" === a && !0 !== n || \"horizontal\" === t && \"stacked\" === i && !0 === n) && r.reverse(), r;\n    }(t, r, a, n, d, u);\n  },\n  ke = function (e, t, a) {\n    var i = e.get(t) || 0;\n    e.set(t, i + a);\n  },\n  we = function (e, t, a) {\n    var i = e.get(t) || 0;\n    e.set(t, i + (a > 0 ? a : 0));\n  },\n  Le = function (e, t, a) {\n    var i = e.get(t) || 0;\n    e.set(t, Math.max(i, Number(a)));\n  },\n  Ce = function (e, t) {\n    var a = e.get(t) || 0;\n    e.set(t, a + 1);\n  },\n  Ve = function (e) {\n    var t = e.indexBy,\n      a = void 0 === t ? ee.indexBy : t,\n      i = e.keys,\n      l = void 0 === i ? ee.keys : i,\n      d = e.label,\n      u = void 0 === d ? ee.label : d,\n      c = e.tooltipLabel,\n      s = void 0 === c ? ee.tooltipLabel : c,\n      h = e.valueFormat,\n      f = e.colors,\n      b = void 0 === f ? ee.colors : f,\n      v = e.colorBy,\n      g = void 0 === v ? ee.colorBy : v,\n      m = e.borderColor,\n      p = void 0 === m ? ee.borderColor : m,\n      x = e.labelTextColor,\n      S = void 0 === x ? ee.labelTextColor : x,\n      L = e.groupMode,\n      C = void 0 === L ? ee.groupMode : L,\n      V = e.layout,\n      M = void 0 === V ? ee.layout : V,\n      W = e.reverse,\n      T = void 0 === W ? ee.reverse : W,\n      B = e.data,\n      O = e.minValue,\n      I = void 0 === O ? ee.minValue : O,\n      P = e.maxValue,\n      E = void 0 === P ? ee.maxValue : P,\n      H = e.margin,\n      R = e.width,\n      A = e.height,\n      X = e.padding,\n      Y = void 0 === X ? ee.padding : X,\n      G = e.innerPadding,\n      z = void 0 === G ? ee.innerPadding : G,\n      N = e.valueScale,\n      q = void 0 === N ? ee.valueScale : N,\n      K = e.indexScale,\n      _ = void 0 === K ? ee.indexScale : K,\n      J = e.initialHiddenIds,\n      Q = void 0 === J ? ee.initialHiddenIds : J,\n      U = e.enableLabel,\n      Z = void 0 === U ? ee.enableLabel : U,\n      $ = e.labelSkipWidth,\n      te = void 0 === $ ? ee.labelSkipWidth : $,\n      ae = e.labelSkipHeight,\n      ie = void 0 === ae ? ee.labelSkipHeight : ae,\n      ne = e.legends,\n      le = void 0 === ne ? ee.legends : ne,\n      re = e.legendLabel,\n      oe = e.totalsOffset,\n      de = void 0 === oe ? ee.totalsOffset : oe,\n      ue = w(null != Q ? Q : []),\n      ce = ue[0],\n      se = ue[1],\n      he = k(function (e) {\n        se(function (t) {\n          return t.indexOf(e) > -1 ? t.filter(function (t) {\n            return t !== e;\n          }) : [].concat(t, [e]);\n        });\n      }, []),\n      fe = r(a),\n      be = r(u),\n      ge = r(s),\n      me = o(h),\n      pe = n(),\n      xe = F(b, g),\n      Ve = D(p, pe),\n      Me = D(S, pe),\n      We = (\"grouped\" === C ? ve : ye)({\n        layout: M,\n        reverse: T,\n        data: B,\n        getIndex: fe,\n        keys: l,\n        minValue: I,\n        maxValue: E,\n        width: R,\n        height: A,\n        getColor: xe,\n        padding: Y,\n        innerPadding: z,\n        valueScale: q,\n        indexScale: _,\n        hiddenIds: ce,\n        formatValue: me,\n        getTooltipLabel: ge,\n        margin: H\n      }),\n      Te = We.bars,\n      Be = We.xScale,\n      Oe = We.yScale,\n      Ie = y(function () {\n        return Te.filter(function (e) {\n          return null !== e.data.value;\n        }).map(function (e, t) {\n          return j({}, e, {\n            index: t\n          });\n        });\n      }, [Te]),\n      Pe = k(function (e) {\n        var t = e.width,\n          a = e.height;\n        return !!Z && !(te > 0 && t < te) && !(ie > 0 && a < ie);\n      }, [Z, te, ie]),\n      Ee = y(function () {\n        return l.map(function (e) {\n          var t = Te.find(function (t) {\n            return t.data.id === e;\n          });\n          return j({}, t, {\n            data: j({\n              id: e\n            }, null == t ? void 0 : t.data, {\n              hidden: ce.includes(e)\n            })\n          });\n        });\n      }, [ce, l, Te]),\n      He = y(function () {\n        return le.map(function (e) {\n          return [e, Se({\n            bars: \"keys\" === e.dataFrom ? Ee : Te,\n            direction: e.direction,\n            from: e.dataFrom,\n            groupMode: C,\n            layout: M,\n            legendLabel: re,\n            reverse: T\n          })];\n        });\n      }, [le, Ee, Te, C, M, re, T]),\n      Re = y(function () {\n        return function (e, t, a, i, n, l, r) {\n          void 0 === i && (i = ee.layout), void 0 === n && (n = ee.groupMode);\n          var o = [];\n          if (0 === e.length) return o;\n          var d = new Map(),\n            u = e[0].width,\n            c = e[0].height;\n          if (\"stacked\" === n) {\n            var s = new Map();\n            e.forEach(function (e) {\n              var t = e.data,\n                a = t.indexValue,\n                i = t.value;\n              ke(d, a, Number(i)), we(s, a, Number(i));\n            }), s.forEach(function (e, n) {\n              var s,\n                h,\n                f,\n                b = d.get(n) || 0;\n              \"vertical\" === i ? (s = t(n), h = a(e), f = a(e / 2)) : (s = t(e), h = a(n), f = t(e / 2)), s += \"vertical\" === i ? u / 2 : l, h += \"vertical\" === i ? -l : c / 2, o.push({\n                key: \"total_\" + n,\n                x: s,\n                y: h,\n                value: b,\n                formattedValue: r(b),\n                animationOffset: f\n              });\n            });\n          } else if (\"grouped\" === n) {\n            var h = new Map(),\n              f = new Map();\n            e.forEach(function (e) {\n              var t = e.data,\n                a = t.indexValue,\n                i = t.value;\n              ke(d, a, Number(i)), Le(h, a, Number(i)), Ce(f, a);\n            }), h.forEach(function (e, n) {\n              var s,\n                h,\n                b,\n                v = d.get(n) || 0,\n                g = f.get(n);\n              \"vertical\" === i ? (s = t(n), h = a(e), b = a(e / 2)) : (s = t(e), h = a(n), b = t(e / 2)), s += \"vertical\" === i ? g * u / 2 : l, h += \"vertical\" === i ? -l : g * c / 2, o.push({\n                key: \"total_\" + n,\n                x: s,\n                y: h,\n                value: v,\n                formattedValue: r(v),\n                animationOffset: b\n              });\n            });\n          }\n          return o;\n        }(Te, Be, Oe, M, C, de, me);\n      }, [Te, Be, Oe, M, C, de, me]);\n    return {\n      bars: Te,\n      barsWithValue: Ie,\n      xScale: Be,\n      yScale: Oe,\n      getIndex: fe,\n      getLabel: be,\n      getTooltipLabel: ge,\n      formatValue: me,\n      getColor: xe,\n      getBorderColor: Ve,\n      getLabelColor: Me,\n      shouldRenderBarLabel: Pe,\n      hiddenIds: ce,\n      toggleSerie: he,\n      legendsWithData: He,\n      barTotals: Re\n    };\n  },\n  Me = function (e) {\n    var t = e.data,\n      a = e.springConfig,\n      i = e.animate,\n      l = e.layout,\n      r = void 0 === l ? te.layout : l,\n      o = n();\n    return x(t, {\n      keys: function (e) {\n        return e.key;\n      },\n      from: function (e) {\n        return {\n          x: \"vertical\" === r ? e.x : e.animationOffset,\n          y: \"vertical\" === r ? e.animationOffset : e.y,\n          labelOpacity: 0\n        };\n      },\n      enter: function (e) {\n        return {\n          x: e.x,\n          y: e.y,\n          labelOpacity: 1\n        };\n      },\n      update: function (e) {\n        return {\n          x: e.x,\n          y: e.y,\n          labelOpacity: 1\n        };\n      },\n      leave: function (e) {\n        return {\n          x: \"vertical\" === r ? e.x : e.animationOffset,\n          y: \"vertical\" === r ? e.animationOffset : e.y,\n          labelOpacity: 0\n        };\n      },\n      config: a,\n      immediate: !i,\n      initial: i ? void 0 : null\n    })(function (e, t) {\n      return I(m.text, {\n        x: e.x,\n        y: e.y,\n        fillOpacity: e.labelOpacity,\n        style: j({}, o.labels.text, {\n          pointerEvents: \"none\",\n          fill: o.text.fill\n        }),\n        fontWeight: \"bold\",\n        fontSize: o.labels.text.fontSize,\n        fontFamily: o.labels.text.fontFamily,\n        textAnchor: \"vertical\" === r ? \"middle\" : \"start\",\n        alignmentBaseline: \"vertical\" === r ? \"alphabetic\" : \"middle\",\n        children: t.formattedValue\n      }, t.key);\n    });\n  },\n  We = [\"isInteractive\", \"animate\", \"motionConfig\", \"theme\", \"renderWrapper\"],\n  Te = function (a) {\n    var i = a.data,\n      n = a.indexBy,\n      l = a.keys,\n      r = a.margin,\n      o = a.width,\n      d = a.height,\n      b = a.groupMode,\n      v = a.layout,\n      g = a.reverse,\n      m = a.minValue,\n      p = a.maxValue,\n      k = a.valueScale,\n      w = a.indexScale,\n      C = a.padding,\n      V = a.innerPadding,\n      M = a.axisTop,\n      W = a.axisRight,\n      T = a.axisBottom,\n      B = void 0 === T ? te.axisBottom : T,\n      O = a.axisLeft,\n      P = void 0 === O ? te.axisLeft : O,\n      E = a.enableGridX,\n      H = void 0 === E ? te.enableGridX : E,\n      R = a.enableGridY,\n      F = void 0 === R ? te.enableGridY : R,\n      D = a.gridXValues,\n      A = a.gridYValues,\n      X = a.layers,\n      Y = void 0 === X ? te.layers : X,\n      G = a.barComponent,\n      z = void 0 === G ? te.barComponent : G,\n      N = a.enableLabel,\n      q = void 0 === N ? te.enableLabel : N,\n      K = a.label,\n      Q = a.labelSkipWidth,\n      U = void 0 === Q ? te.labelSkipWidth : Q,\n      Z = a.labelSkipHeight,\n      $ = void 0 === Z ? te.labelSkipHeight : Z,\n      ee = a.labelTextColor,\n      ae = a.labelPosition,\n      ie = void 0 === ae ? te.labelPosition : ae,\n      ne = a.labelOffset,\n      le = void 0 === ne ? te.labelOffset : ne,\n      re = a.markers,\n      de = void 0 === re ? te.markers : re,\n      ue = a.colorBy,\n      ce = a.colors,\n      se = a.defs,\n      he = void 0 === se ? te.defs : se,\n      fe = a.fill,\n      be = void 0 === fe ? te.fill : fe,\n      ve = a.borderRadius,\n      ge = void 0 === ve ? te.borderRadius : ve,\n      me = a.borderWidth,\n      pe = void 0 === me ? te.borderWidth : me,\n      xe = a.borderColor,\n      ye = a.annotations,\n      Se = void 0 === ye ? te.annotations : ye,\n      ke = a.legendLabel,\n      we = a.tooltipLabel,\n      Le = a.valueFormat,\n      Ce = a.isInteractive,\n      We = void 0 === Ce ? te.isInteractive : Ce,\n      Te = a.tooltip,\n      Be = void 0 === Te ? te.tooltip : Te,\n      Oe = a.onClick,\n      Ie = a.onMouseEnter,\n      Pe = a.onMouseLeave,\n      Ee = a.legends,\n      He = a.role,\n      Re = void 0 === He ? te.role : He,\n      Fe = a.ariaLabel,\n      De = a.ariaLabelledBy,\n      Ae = a.ariaDescribedBy,\n      Xe = a.isFocusable,\n      Ye = void 0 === Xe ? te.isFocusable : Xe,\n      Ge = a.barAriaLabel,\n      ze = a.barAriaLabelledBy,\n      Ne = a.barAriaDescribedBy,\n      je = a.barAriaHidden,\n      qe = a.barAriaDisabled,\n      Ke = a.initialHiddenIds,\n      _e = a.enableTotals,\n      Je = void 0 === _e ? te.enableTotals : _e,\n      Qe = a.totalsOffset,\n      Ue = void 0 === Qe ? te.totalsOffset : Qe,\n      Ze = u(),\n      $e = Ze.animate,\n      et = Ze.config,\n      tt = c(o, d, r),\n      at = tt.outerWidth,\n      it = tt.outerHeight,\n      nt = tt.margin,\n      lt = tt.innerWidth,\n      rt = tt.innerHeight,\n      ot = Ve({\n        indexBy: n,\n        label: K,\n        tooltipLabel: we,\n        valueFormat: Le,\n        colors: ce,\n        colorBy: ue,\n        borderColor: xe,\n        labelTextColor: ee,\n        groupMode: b,\n        layout: v,\n        reverse: g,\n        data: i,\n        keys: l,\n        minValue: m,\n        maxValue: p,\n        margin: nt,\n        width: lt,\n        height: rt,\n        padding: C,\n        innerPadding: V,\n        valueScale: k,\n        indexScale: w,\n        enableLabel: q,\n        labelSkipWidth: U,\n        labelSkipHeight: $,\n        legends: Ee,\n        legendLabel: ke,\n        initialHiddenIds: Ke,\n        totalsOffset: Ue\n      }),\n      dt = ot.bars,\n      ut = ot.barsWithValue,\n      ct = ot.xScale,\n      st = ot.yScale,\n      ht = ot.getLabel,\n      ft = ot.getTooltipLabel,\n      bt = ot.getBorderColor,\n      vt = ot.getLabelColor,\n      gt = ot.shouldRenderBarLabel,\n      mt = ot.toggleSerie,\n      pt = ot.legendsWithData,\n      xt = ot.barTotals,\n      yt = ot.getColor,\n      St = oe(v, g, ie, le),\n      kt = x(ut, {\n        keys: function (e) {\n          return e.key;\n        },\n        from: function (e) {\n          return j({\n            borderColor: bt(e),\n            color: e.color,\n            height: 0,\n            labelColor: vt(e),\n            labelOpacity: 0\n          }, St(e.width, e.height), {\n            transform: \"translate(\" + e.x + \", \" + (e.y + e.height) + \")\",\n            width: e.width\n          }, \"vertical\" === v ? {} : {\n            height: e.height,\n            transform: \"translate(\" + e.x + \", \" + e.y + \")\",\n            width: 0\n          });\n        },\n        enter: function (e) {\n          return j({\n            borderColor: bt(e),\n            color: e.color,\n            height: e.height,\n            labelColor: vt(e),\n            labelOpacity: 1\n          }, St(e.width, e.height), {\n            transform: \"translate(\" + e.x + \", \" + e.y + \")\",\n            width: e.width\n          });\n        },\n        update: function (e) {\n          return j({\n            borderColor: bt(e),\n            color: e.color,\n            height: e.height,\n            labelColor: vt(e),\n            labelOpacity: 1\n          }, St(e.width, e.height), {\n            transform: \"translate(\" + e.x + \", \" + e.y + \")\",\n            width: e.width\n          });\n        },\n        leave: function (e) {\n          return j({\n            borderColor: bt(e),\n            color: e.color,\n            height: 0,\n            labelColor: vt(e),\n            labelOpacity: 0\n          }, St(e.width, e.height), {\n            labelY: 0,\n            transform: \"translate(\" + e.x + \", \" + (e.y + e.height) + \")\",\n            width: e.width\n          }, \"vertical\" === v ? {} : j({}, St(e.width, e.height), {\n            labelX: 0,\n            height: e.height,\n            transform: \"translate(\" + e.x + \", \" + e.y + \")\",\n            width: 0\n          }));\n        },\n        config: et,\n        immediate: !$e,\n        initial: $e ? void 0 : null\n      }),\n      wt = y(function () {\n        return {\n          borderRadius: ge,\n          borderWidth: pe,\n          enableLabel: q,\n          isInteractive: We,\n          labelSkipWidth: U,\n          labelSkipHeight: $,\n          onClick: Oe,\n          onMouseEnter: Ie,\n          onMouseLeave: Pe,\n          getTooltipLabel: ft,\n          tooltip: Be,\n          isFocusable: Ye,\n          ariaLabel: Ge,\n          ariaLabelledBy: ze,\n          ariaDescribedBy: Ne,\n          ariaHidden: je,\n          ariaDisabled: qe\n        };\n      }, [ge, pe, q, ft, We, $, U, Oe, Ie, Pe, Be, Ye, Ge, ze, Ne, je, qe]),\n      Lt = s(he, dt, be, {\n        dataKey: \"data\",\n        targetKey: \"data.fill\"\n      }),\n      Ct = {\n        annotations: null,\n        axes: null,\n        bars: null,\n        grid: null,\n        legends: null,\n        markers: null,\n        totals: null\n      };\n    Y.includes(\"annotations\") && (Ct.annotations = I(_, {\n      bars: dt,\n      annotations: Se\n    }, \"annotations\")), Y.includes(\"axes\") && (Ct.axes = I(e, {\n      xScale: ct,\n      yScale: st,\n      width: lt,\n      height: rt,\n      top: M,\n      right: W,\n      bottom: B,\n      left: P\n    }, \"axes\")), Y.includes(\"bars\") && (Ct.bars = I(L, {\n      children: kt(function (e, t) {\n        return S(z, j({}, wt, {\n          bar: t,\n          style: e,\n          shouldRenderLabel: gt(t),\n          label: ht(t.data)\n        }));\n      })\n    }, \"bars\")), Y.includes(\"grid\") && (Ct.grid = I(t, {\n      width: lt,\n      height: rt,\n      xScale: H ? ct : null,\n      yScale: F ? st : null,\n      xValues: D,\n      yValues: A\n    }, \"grid\")), Y.includes(\"legends\") && (Ct.legends = I(J, {\n      width: lt,\n      height: rt,\n      legends: pt,\n      toggleSerie: mt\n    }, \"legends\")), Y.includes(\"markers\") && (Ct.markers = I(h, {\n      markers: de,\n      width: lt,\n      height: rt,\n      xScale: ct,\n      yScale: st\n    }, \"markers\")), Y.includes(\"totals\") && Je && (Ct.totals = I(Me, {\n      data: xt,\n      springConfig: et,\n      animate: $e,\n      layout: v\n    }, \"totals\"));\n    var Vt = y(function () {\n      return j({}, wt, {\n        margin: nt,\n        width: o,\n        height: d,\n        innerWidth: lt,\n        innerHeight: rt,\n        bars: dt,\n        legendData: pt,\n        enableLabel: q,\n        xScale: ct,\n        yScale: st,\n        tooltip: Be,\n        getTooltipLabel: ft,\n        onClick: Oe,\n        onMouseEnter: Ie,\n        onMouseLeave: Pe,\n        getColor: yt\n      });\n    }, [wt, nt, o, d, lt, rt, dt, pt, q, ct, st, Be, ft, Oe, Ie, Pe, yt]);\n    return I(f, {\n      width: at,\n      height: it,\n      margin: nt,\n      defs: Lt,\n      role: Re,\n      ariaLabel: Fe,\n      ariaLabelledBy: De,\n      ariaDescribedBy: Ae,\n      isFocusable: Ye,\n      children: Y.map(function (e, t) {\n        var a;\n        return \"function\" == typeof e ? I(L, {\n          children: S(e, Vt)\n        }, t) : null != (a = null == Ct ? void 0 : Ct[e]) ? a : null;\n      })\n    });\n  },\n  Be = function (e) {\n    var t = e.isInteractive,\n      a = void 0 === t ? te.isInteractive : t,\n      i = e.animate,\n      n = void 0 === i ? te.animate : i,\n      l = e.motionConfig,\n      r = void 0 === l ? te.motionConfig : l,\n      o = e.theme,\n      u = e.renderWrapper,\n      c = q(e, We);\n    return I(d, {\n      animate: n,\n      isInteractive: a,\n      motionConfig: r,\n      renderWrapper: u,\n      theme: o,\n      children: I(Te, j({\n        isInteractive: a\n      }, c))\n    });\n  },\n  Oe = [\"isInteractive\", \"renderWrapper\", \"theme\"],\n  Ie = function (e, t, a, i) {\n    return e.find(function (e) {\n      return v(e.x + t.left, e.y + t.top, e.width, e.height, a, i);\n    });\n  };\nvar Pe = function (e) {\n    var t = e.data,\n      l = e.indexBy,\n      r = e.keys,\n      d = e.margin,\n      u = e.width,\n      s = e.height,\n      h = e.groupMode,\n      f = e.layout,\n      v = e.reverse,\n      g = e.minValue,\n      m = e.maxValue,\n      p = e.valueScale,\n      x = e.indexScale,\n      w = e.padding,\n      L = e.innerPadding,\n      C = e.axisTop,\n      T = e.axisRight,\n      P = e.axisBottom,\n      E = void 0 === P ? ae.axisBottom : P,\n      H = e.axisLeft,\n      F = void 0 === H ? ae.axisLeft : H,\n      D = e.enableGridX,\n      X = void 0 === D ? ae.enableGridX : D,\n      Y = e.enableGridY,\n      G = void 0 === Y ? ae.enableGridY : Y,\n      z = e.gridXValues,\n      N = e.gridYValues,\n      q = e.labelPosition,\n      K = void 0 === q ? ae.labelPosition : q,\n      _ = e.labelOffset,\n      J = void 0 === _ ? ae.labelOffset : _,\n      Q = e.layers,\n      U = void 0 === Q ? ae.layers : Q,\n      Z = e.renderBar,\n      $ = void 0 === Z ? function (e, t) {\n        var a = t.bar,\n          i = a.color,\n          n = a.height,\n          l = a.width,\n          r = a.x,\n          o = a.y,\n          d = t.borderColor,\n          u = t.borderRadius,\n          c = t.borderWidth,\n          s = t.label,\n          h = t.labelColor,\n          f = t.shouldRenderLabel,\n          b = t.labelX,\n          v = t.labelY,\n          g = t.textAnchor;\n        if (e.fillStyle = i, c > 0 && (e.strokeStyle = d, e.lineWidth = c), e.beginPath(), u > 0) {\n          var m = Math.min(u, n);\n          e.moveTo(r + m, o), e.lineTo(r + l - m, o), e.quadraticCurveTo(r + l, o, r + l, o + m), e.lineTo(r + l, o + n - m), e.quadraticCurveTo(r + l, o + n, r + l - m, o + n), e.lineTo(r + m, o + n), e.quadraticCurveTo(r, o + n, r, o + n - m), e.lineTo(r, o + m), e.quadraticCurveTo(r, o, r + m, o), e.closePath();\n        } else e.rect(r, o, l, n);\n        e.fill(), c > 0 && e.stroke(), f && (e.textBaseline = \"middle\", e.textAlign = \"middle\" === g ? \"center\" : g, e.fillStyle = h, e.fillText(s, r + b, o + v));\n      } : Z,\n      ee = e.enableLabel,\n      te = void 0 === ee ? ae.enableLabel : ee,\n      ie = e.label,\n      ne = e.labelSkipWidth,\n      le = void 0 === ne ? ae.labelSkipWidth : ne,\n      re = e.labelSkipHeight,\n      de = void 0 === re ? ae.labelSkipHeight : re,\n      ue = e.labelTextColor,\n      ce = e.colorBy,\n      se = e.colors,\n      he = e.borderRadius,\n      fe = void 0 === he ? ae.borderRadius : he,\n      be = e.borderWidth,\n      ve = void 0 === be ? ae.borderWidth : be,\n      ge = e.borderColor,\n      me = e.annotations,\n      pe = void 0 === me ? ae.annotations : me,\n      xe = e.legendLabel,\n      ye = e.tooltipLabel,\n      Se = e.valueFormat,\n      ke = e.isInteractive,\n      we = void 0 === ke ? ae.isInteractive : ke,\n      Le = e.tooltip,\n      Ce = void 0 === Le ? ae.tooltip : Le,\n      Me = e.onClick,\n      We = e.onMouseEnter,\n      Te = e.onMouseLeave,\n      Be = e.legends,\n      Oe = e.pixelRatio,\n      Pe = void 0 === Oe ? ae.pixelRatio : Oe,\n      Ee = e.canvasRef,\n      He = e.enableTotals,\n      Re = void 0 === He ? ae.enableTotals : He,\n      Fe = e.totalsOffset,\n      De = void 0 === Fe ? ae.totalsOffset : Fe,\n      Ae = V(null),\n      Xe = n(),\n      Ye = c(u, s, d),\n      Ge = Ye.margin,\n      ze = Ye.innerWidth,\n      Ne = Ye.innerHeight,\n      je = Ye.outerWidth,\n      qe = Ye.outerHeight,\n      Ke = Ve({\n        indexBy: l,\n        label: ie,\n        tooltipLabel: ye,\n        valueFormat: Se,\n        colors: se,\n        colorBy: ce,\n        borderColor: ge,\n        labelTextColor: ue,\n        groupMode: h,\n        layout: f,\n        reverse: v,\n        data: t,\n        keys: r,\n        minValue: g,\n        maxValue: m,\n        margin: Ge,\n        width: ze,\n        height: Ne,\n        padding: w,\n        innerPadding: L,\n        valueScale: p,\n        indexScale: x,\n        enableLabel: te,\n        labelSkipWidth: le,\n        labelSkipHeight: de,\n        legends: Be,\n        legendLabel: xe,\n        totalsOffset: De\n      }),\n      _e = Ke.bars,\n      Je = Ke.barsWithValue,\n      Qe = Ke.xScale,\n      Ue = Ke.yScale,\n      Ze = Ke.getLabel,\n      $e = Ke.getTooltipLabel,\n      et = Ke.getBorderColor,\n      tt = Ke.getLabelColor,\n      at = Ke.shouldRenderBarLabel,\n      it = Ke.legendsWithData,\n      nt = Ke.barTotals,\n      lt = Ke.getColor,\n      rt = A(),\n      ot = rt.showTooltipFromEvent,\n      dt = rt.hideTooltip,\n      ut = B({\n        annotations: W({\n          data: _e,\n          annotations: pe,\n          getPosition: function (e) {\n            return {\n              x: e.x,\n              y: e.y\n            };\n          },\n          getDimensions: function (e) {\n            var t = e.width,\n              a = e.height;\n            return {\n              width: t,\n              height: a,\n              size: Math.max(t, a)\n            };\n          }\n        })\n      }),\n      ct = y(function () {\n        return {\n          borderRadius: fe,\n          borderWidth: ve,\n          isInteractive: we,\n          isFocusable: !1,\n          labelSkipWidth: le,\n          labelSkipHeight: de,\n          margin: Ge,\n          width: u,\n          height: s,\n          innerWidth: ze,\n          innerHeight: Ne,\n          bars: _e,\n          legendData: it,\n          enableLabel: te,\n          xScale: Qe,\n          yScale: Ue,\n          tooltip: Ce,\n          getTooltipLabel: $e,\n          onClick: Me,\n          onMouseEnter: We,\n          onMouseLeave: Te,\n          getColor: lt\n        };\n      }, [fe, ve, we, le, de, Ge, u, s, ze, Ne, _e, it, te, Qe, Ue, Ce, $e, Me, We, Te, lt]),\n      st = o(Se),\n      ht = oe(f, v, K, J);\n    M(function () {\n      var e,\n        t = null == (e = Ae.current) ? void 0 : e.getContext(\"2d\");\n      Ae.current && t && (Ae.current.width = je * Pe, Ae.current.height = qe * Pe, t.scale(Pe, Pe), t.fillStyle = Xe.background, t.fillRect(0, 0, je, qe), t.translate(Ge.left, Ge.top), U.forEach(function (e) {\n        \"grid\" === e ? \"number\" == typeof Xe.grid.line.strokeWidth && Xe.grid.line.strokeWidth > 0 && (t.lineWidth = Xe.grid.line.strokeWidth, t.strokeStyle = Xe.grid.line.stroke, X && a(t, {\n          width: ze,\n          height: Ne,\n          scale: Qe,\n          axis: \"x\",\n          values: z\n        }), G && a(t, {\n          width: ze,\n          height: Ne,\n          scale: Ue,\n          axis: \"y\",\n          values: N\n        })) : \"axes\" === e ? i(t, {\n          xScale: Qe,\n          yScale: Ue,\n          width: ze,\n          height: Ne,\n          top: C,\n          right: T,\n          bottom: E,\n          left: F,\n          theme: Xe\n        }) : \"bars\" === e ? Je.forEach(function (e) {\n          $(t, j({\n            bar: e,\n            borderColor: et(e),\n            borderRadius: fe,\n            borderWidth: ve,\n            label: Ze(e.data),\n            labelColor: tt(e),\n            shouldRenderLabel: at(e)\n          }, ht(e.width, e.height)));\n        }) : \"legends\" === e ? it.forEach(function (e) {\n          var a = e[0],\n            i = e[1];\n          R(t, j({}, a, {\n            data: i,\n            containerWidth: ze,\n            containerHeight: Ne,\n            theme: Xe\n          }));\n        }) : \"annotations\" === e ? O(t, {\n          annotations: ut,\n          theme: Xe\n        }) : \"totals\" === e && Re ? function (e, t, a, i) {\n          void 0 === i && (i = ae.layout), e.fillStyle = a.text.fill, e.font = \"bold \" + a.labels.text.fontSize + \"px \" + a.labels.text.fontFamily, e.textBaseline = \"vertical\" === i ? \"alphabetic\" : \"middle\", e.textAlign = \"vertical\" === i ? \"center\" : \"start\", t.forEach(function (t) {\n            e.fillText(t.formattedValue, t.x, t.y);\n          });\n        }(t, nt, Xe, f) : \"function\" == typeof e && e(t, ct);\n      }), t.save());\n    }, [E, F, T, C, Je, fe, ve, ut, X, G, et, Ze, tt, z, N, h, s, Ne, ze, ct, U, f, it, Ge.left, Ge.top, qe, je, Pe, $, Qe, Ue, v, at, Xe, u, nt, Re, st, ht]);\n    var ft = k(function (e) {\n        if (_e && Ae.current) {\n          var t = b(Ae.current, e),\n            a = t[0],\n            i = t[1],\n            n = Ie(_e, Ge, a, i);\n          void 0 !== n ? (ot(S(Ce, j({}, n.data, {\n            color: n.color,\n            label: n.label,\n            value: Number(n.data.value)\n          })), e), \"mouseenter\" === e.type && (null == We || We(n.data, e))) : dt();\n        }\n      }, [dt, Ge, We, _e, ot, Ce]),\n      bt = k(function (e) {\n        if (_e && Ae.current) {\n          dt();\n          var t = b(Ae.current, e),\n            a = t[0],\n            i = t[1],\n            n = Ie(_e, Ge, a, i);\n          n && (null == Te || Te(n.data, e));\n        }\n      }, [dt, Ge, Te, _e]),\n      vt = k(function (e) {\n        if (_e && Ae.current) {\n          var t = b(Ae.current, e),\n            a = t[0],\n            i = t[1],\n            n = Ie(_e, Ge, a, i);\n          void 0 !== n && (null == Me || Me(j({}, n.data, {\n            color: n.color\n          }), e));\n        }\n      }, [Ge, Me, _e]);\n    return I(\"canvas\", {\n      ref: function (e) {\n        Ae.current = e, Ee && \"current\" in Ee && (Ee.current = e);\n      },\n      width: je * Pe,\n      height: qe * Pe,\n      style: {\n        width: je,\n        height: qe,\n        cursor: we ? \"auto\" : \"normal\"\n      },\n      onMouseEnter: we ? ft : void 0,\n      onMouseMove: we ? ft : void 0,\n      onMouseLeave: we ? bt : void 0,\n      onClick: we ? vt : void 0\n    });\n  },\n  Ee = C(function (e, t) {\n    var a = e.isInteractive,\n      i = e.renderWrapper,\n      n = e.theme,\n      l = q(e, Oe);\n    return I(d, {\n      isInteractive: a,\n      renderWrapper: i,\n      theme: n,\n      animate: !1,\n      children: I(Pe, j({}, l, {\n        canvasRef: t\n      }))\n    });\n  }),\n  He = function (e) {\n    return I(g, {\n      children: function (t) {\n        var a = t.width,\n          i = t.height;\n        return I(Be, j({\n          width: a,\n          height: i\n        }, e));\n      }\n    });\n  },\n  Re = C(function (e, t) {\n    return I(g, {\n      children: function (a) {\n        var i = a.width,\n          n = a.height;\n        return I(Ee, j({\n          width: i,\n          height: n\n        }, e, {\n          ref: t\n        }));\n      }\n    });\n  });\nexport { Be as Bar, Ee as BarCanvas, U as BarItem, $ as BarTooltip, Me as BarTotals, He as ResponsiveBar, Re as ResponsiveBarCanvas, ae as canvasDefaultProps, ee as defaultProps, te as svgDefaultProps };\n//# sourceMappingURL=nivo-bar.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}