import React, { useMemo } from 'react';
import { ResponsivePie } from '@nivo/pie';
import { Box, Typography, CircularProgress } from '@mui/material';

/**
 * Vulnerability Pie Chart component using Nivo
 * Displays the distribution of vulnerabilities in a more intuitive pie chart
 * 
 * @param {Object} props - Component props
 * @param {Object} props.data - Either analysis data object or chart data from API
 * @param {boolean} props.loading - Loading state
 * @param {number} props.height - Chart height in pixels
 */
const VulnerabilityPieChart = ({ data, loading, height = 300 }) => {
  // Process data to get vulnerability counts by status
  const vulnerabilityData = useMemo(() => {
    // Check if we have the new API data format
    if (data?.data && Array.isArray(data.data)) {
      // We have data from the chart data API - transform it for pie chart
      const total = data.data.reduce((sum, item) => sum + item.count, 0);
      return data.data.map(item => {
        // Calculate percentage ensuring we have a valid number
        const percentage = total > 0 ? Math.round((item.count / total) * 100) : 0;
        return {
          id: item.category,
          label: item.category,
          value: item.count,
          percentage: percentage,
          color: getColorForCategory(item.category)
        };
      });
    }
    
    // Fallback to the old format (analysis object with dependencies)
    if (!data || !data.dependencies || !Array.isArray(data.dependencies)) {
      return [];
    }

    // Initialize counters for vulnerability statuses
    const counts = {
      'Vulnerable': 0,
      'Secure': 0,
      'Unknown': 0
    };

    // Count dependencies by vulnerability status
    data.dependencies.forEach(dependency => {
      if (dependency.isVulnerable) {
        counts['Vulnerable']++;
      } else if (dependency.vulnerableCount === 0) {
        counts['Secure']++;
      } else {
        counts['Unknown']++;
      }
    });

    // Calculate total for percentage calculations
    const total = Object.values(counts).reduce((sum, c) => sum + c, 0);

    // Convert to the format expected by the pie chart
    return Object.entries(counts)
      .filter(([_, count]) => count > 0) // Only include non-zero values
      .map(([category, count]) => {
        // Calculate percentage ensuring we have a valid number
        const percentage = total > 0 ? Math.round((count / total) * 100) : 0;
        return {
          id: category,
          label: category,
          value: count,
          percentage: percentage,
          color: getColorForCategory(category)
        };
      });
  }, [data]);

  // Calculate a clean summary text without any "undefined" in it
  const cleanSummary = useMemo(() => {
    if (!vulnerabilityData || vulnerabilityData.length === 0) return null;
    
    const total = vulnerabilityData.reduce((sum, item) => sum + item.value, 0);
    const vulnerableCount = vulnerabilityData.find(item => item.id === 'Vulnerable')?.value || 0;
    const secureCount = vulnerabilityData.find(item => item.id === 'Secure')?.value || 0;
    const unknownCount = vulnerabilityData.find(item => item.id === 'Unknown')?.value || 0;
    
    let summary = '';
    
    if (vulnerableCount > 0) {
      const percentage = Math.round((vulnerableCount / total) * 100);
      summary += `${vulnerableCount} vulnerable (${percentage}%)`;
    }
    
    if (secureCount > 0) {
      if (summary) summary += ', ';
      const percentage = Math.round((secureCount / total) * 100);
      summary += `${secureCount} secure (${percentage}%)`;
    }
    
    if (unknownCount > 0) {
      if (summary) summary += ', ';
      const percentage = Math.round((unknownCount / total) * 100);
      summary += `${unknownCount} unknown (${percentage}%)`;
    }
    
    return summary || "No vulnerability data available";
  }, [vulnerabilityData]);
  
  // Add the clean summary to the data object if it's going to be used elsewhere
  if (data) {
    data.cleanSummary = cleanSummary || "No vulnerability data available";
  }

  // Return loading indicator if data is loading
  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height }}>
        <CircularProgress />
      </Box>
    );
  }

  // Return message if no data available
  if (vulnerabilityData.length === 0) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height, p: 2 }}>
        <Typography color="text.secondary">No vulnerability data available</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ height }}>
      <ResponsivePie
        data={vulnerabilityData}
        margin={{ top: 20, right: 20, bottom: 40, left: 20 }}
        innerRadius={0.5}
        padAngle={0.7}
        cornerRadius={3}
        activeOuterRadiusOffset={8}
        colors={({ data }) => data.color}
        borderWidth={1}
        borderColor={{ from: 'color', modifiers: [['darker', 0.2]] }}
        arcLinkLabelsSkipAngle={10}
        arcLinkLabelsTextColor="#333333"
        arcLinkLabelsThickness={2}
        arcLinkLabelsColor={{ from: 'color' }}
        arcLabelsSkipAngle={10}
        arcLabelsTextColor={{ from: 'color', modifiers: [['darker', 2]] }}
        tooltip={({ datum }) => (
          <div
            style={{
              background: 'white',
              padding: '9px 12px',
              border: '1px solid #ccc',
              borderRadius: '3px',
              boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
            }}
          >
            <strong style={{ color: datum.color }}>
              {datum.label}: {datum.value} ({datum.data.percentage}%)
            </strong>
          </div>
        )}
        valueFormat={value => `${value}`}
        defs={[
          {
            id: 'gradient',
            type: 'linearGradient',
            colors: [
              { offset: 0, color: 'inherit' },
              { offset: 100, color: 'inherit', opacity: 0.7 }
            ]
          }
        ]}
        fill={[
          { match: '*', id: 'gradient' }
        ]}
        legends={[
          {
            anchor: 'bottom',
            direction: 'row',
            justify: false,
            translateX: 0,
            translateY: 40,
            itemsSpacing: 20,
            itemWidth: 80,
            itemHeight: 20,
            itemTextColor: '#333',
            itemDirection: 'left-to-right',
            itemOpacity: 1,
            symbolSize: 15,
            symbolShape: 'circle'
          }
        ]}
      />
    </Box>
  );
};

// Helper function to get color based on vulnerability category
function getColorForCategory(category) {
  switch (category) {
    case 'Vulnerable':
      return '#f44336'; // red
    case 'Secure':
      return '#4caf50'; // green
    case 'Monitored':
      return '#ff9800'; // orange
    case 'Unknown':
      return '#9e9e9e'; // grey
    default:
      return '#9e9e9e'; // grey for any other case
  }
}

export default VulnerabilityPieChart; 