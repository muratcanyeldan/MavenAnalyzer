{"ast":null,"code":"import { jsx as t, jsxs as e } from \"react/jsx-runtime\";\nimport { scaleLinear as i } from \"d3-scale\";\nimport { getValueFormatter as n, useTheme as o, sanitizeSvgTextStyle as r, degreesToRadians as l } from \"@nivo/core\";\nimport { computeContinuousColorScaleColorStops as a } from \"@nivo/colors\";\nimport * as c from \"react\";\nimport { Fragment as d, useState as s, useCallback as h, useMemo as g } from \"react\";\nvar f = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      d = void 0 === c ? 0 : c,\n      s = e.borderColor;\n    return t(\"circle\", {\n      r: o / 2,\n      cx: i + o / 2,\n      cy: n + o / 2,\n      fill: r,\n      opacity: a,\n      strokeWidth: d,\n      stroke: void 0 === s ? \"transparent\" : s,\n      style: {\n        pointerEvents: \"none\"\n      }\n    });\n  },\n  m = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      d = void 0 === c ? 0 : c,\n      s = e.borderColor;\n    return t(\"g\", {\n      transform: \"translate(\" + i + \",\" + n + \")\",\n      children: t(\"path\", {\n        d: \"\\n                    M\" + o / 2 + \" 0\\n                    L\" + .8 * o + \" \" + o / 2 + \"\\n                    L\" + o / 2 + \" \" + o + \"\\n                    L\" + .2 * o + \" \" + o / 2 + \"\\n                    L\" + o / 2 + \" 0\\n                \",\n        fill: r,\n        opacity: a,\n        strokeWidth: d,\n        stroke: void 0 === s ? \"transparent\" : s,\n        style: {\n          pointerEvents: \"none\"\n        }\n      })\n    });\n  },\n  v = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      d = void 0 === c ? 0 : c,\n      s = e.borderColor;\n    return t(\"rect\", {\n      x: i,\n      y: n,\n      fill: r,\n      opacity: a,\n      strokeWidth: d,\n      stroke: void 0 === s ? \"transparent\" : s,\n      width: o,\n      height: o,\n      style: {\n        pointerEvents: \"none\"\n      }\n    });\n  },\n  u = function (e) {\n    var i = e.x,\n      n = e.y,\n      o = e.size,\n      r = e.fill,\n      l = e.opacity,\n      a = void 0 === l ? 1 : l,\n      c = e.borderWidth,\n      d = void 0 === c ? 0 : c,\n      s = e.borderColor;\n    return t(\"g\", {\n      transform: \"translate(\" + i + \",\" + n + \")\",\n      children: t(\"path\", {\n        d: \"\\n                M\" + o / 2 + \" 0\\n                L\" + o + \" \" + o + \"\\n                L0 \" + o + \"\\n                L\" + o / 2 + \" 0\\n            \",\n        fill: r,\n        opacity: a,\n        strokeWidth: d,\n        stroke: void 0 === s ? \"transparent\" : s,\n        style: {\n          pointerEvents: \"none\"\n        }\n      })\n    });\n  };\nfunction p() {\n  return p = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = arguments[e];\n      for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);\n    }\n    return t;\n  }, p.apply(this, arguments);\n}\nvar y = {\n    length: 200,\n    thickness: 16,\n    direction: \"row\",\n    tickPosition: \"after\",\n    tickSize: 4,\n    tickSpacing: 3,\n    tickOverlap: !1,\n    tickFormat: function (t) {\n      return \"\" + t;\n    },\n    titleAlign: \"start\",\n    titleOffset: 4\n  },\n  k = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  },\n  x = function (t) {\n    var e,\n      i = t.direction,\n      n = t.itemsSpacing,\n      o = t.padding,\n      r = t.itemCount,\n      l = t.itemWidth,\n      a = t.itemHeight;\n    if (\"number\" != typeof o && (\"object\" != typeof (e = o) || Array.isArray(e) || null === e)) throw new Error(\"Invalid property padding, must be one of: number, object\");\n    var c = \"number\" == typeof o ? {\n        top: o,\n        right: o,\n        bottom: o,\n        left: o\n      } : p({}, k, o),\n      d = c.left + c.right,\n      s = c.top + c.bottom,\n      h = l + d,\n      g = a + s,\n      f = (r - 1) * n;\n    return \"row\" === i ? h = l * r + f + d : \"column\" === i && (g = a * r + f + s), {\n      width: h,\n      height: g,\n      padding: c\n    };\n  },\n  b = function (t) {\n    var e = t.anchor,\n      i = t.translateX,\n      n = t.translateY,\n      o = t.containerWidth,\n      r = t.containerHeight,\n      l = t.width,\n      a = t.height,\n      c = i,\n      d = n;\n    switch (e) {\n      case \"top\":\n        c += (o - l) / 2;\n        break;\n      case \"top-right\":\n        c += o - l;\n        break;\n      case \"right\":\n        c += o - l, d += (r - a) / 2;\n        break;\n      case \"bottom-right\":\n        c += o - l, d += r - a;\n        break;\n      case \"bottom\":\n        c += (o - l) / 2, d += r - a;\n        break;\n      case \"bottom-left\":\n        d += r - a;\n        break;\n      case \"left\":\n        d += (r - a) / 2;\n        break;\n      case \"center\":\n        c += (o - l) / 2, d += (r - a) / 2;\n    }\n    return {\n      x: c,\n      y: d\n    };\n  },\n  S = function (t) {\n    var e,\n      i,\n      n,\n      o,\n      r,\n      l,\n      a = t.direction,\n      c = t.justify,\n      d = t.symbolSize,\n      s = t.symbolSpacing,\n      h = t.width,\n      g = t.height;\n    switch (a) {\n      case \"left-to-right\":\n        e = 0, i = (g - d) / 2, o = g / 2, l = \"central\", c ? (n = h, r = \"end\") : (n = d + s, r = \"start\");\n        break;\n      case \"right-to-left\":\n        e = h - d, i = (g - d) / 2, o = g / 2, l = \"central\", c ? (n = 0, r = \"start\") : (n = h - d - s, r = \"end\");\n        break;\n      case \"top-to-bottom\":\n        e = (h - d) / 2, i = 0, n = h / 2, r = \"middle\", c ? (o = g, l = \"alphabetic\") : (o = d + s, l = \"text-before-edge\");\n        break;\n      case \"bottom-to-top\":\n        e = (h - d) / 2, i = g - d, n = h / 2, r = \"middle\", c ? (o = 0, l = \"text-before-edge\") : (o = g - d - s, l = \"alphabetic\");\n    }\n    return {\n      symbolX: e,\n      symbolY: i,\n      labelX: n,\n      labelY: o,\n      labelAnchor: r,\n      labelAlignment: l\n    };\n  },\n  A = function (t) {\n    var e,\n      o = t.scale,\n      r = t.ticks,\n      l = t.length,\n      c = void 0 === l ? y.length : l,\n      d = t.thickness,\n      s = void 0 === d ? y.thickness : d,\n      h = t.direction,\n      g = void 0 === h ? y.direction : h,\n      f = t.tickPosition,\n      m = void 0 === f ? y.tickPosition : f,\n      v = t.tickSize,\n      u = void 0 === v ? y.tickSize : v,\n      p = t.tickSpacing,\n      k = void 0 === p ? y.tickSpacing : p,\n      x = t.tickOverlap,\n      b = void 0 === x ? y.tickOverlap : x,\n      S = t.tickFormat,\n      A = void 0 === S ? y.tickFormat : S,\n      W = t.title,\n      z = t.titleAlign,\n      C = void 0 === z ? y.titleAlign : z,\n      w = t.titleOffset,\n      X = void 0 === w ? y.titleOffset : w,\n      Y = \"column\" === g ? [].concat(o.domain()).reverse() : o.domain(),\n      O = i().domain(Y);\n    2 === Y.length ? O.range([0, c]) : 3 === Y.length && O.range([0, c / 2, c]), e = \"thresholds\" in o ? [Y[0]].concat(o.thresholds(), [Y[1]]) : Array.isArray(r) ? r : o.ticks(r);\n    var B,\n      H,\n      E,\n      j,\n      L,\n      M,\n      F = a(o, 32),\n      T = n(A),\n      P = [],\n      V = 0,\n      R = 0;\n    if (\"row\" === g) {\n      var D, q, G;\n      B = c, H = s, R = 1;\n      var I;\n      L = 0, E = \"start\" === C ? 0 : \"middle\" === C ? c / 2 : c, \"before\" === m ? (D = -u, q = b ? s : 0, G = -u - k, I = \"alphabetic\", j = s + X, M = \"hanging\") : (D = b ? 0 : s, G = (q = s + u) + k, I = \"hanging\", j = -X, M = \"alphabetic\"), e.forEach(function (t) {\n        var e = O(t);\n        P.push({\n          x1: e,\n          y1: D,\n          x2: e,\n          y2: q,\n          text: T(t),\n          textX: e,\n          textY: G,\n          textHorizontalAlign: \"middle\",\n          textVerticalAlign: I\n        });\n      });\n    } else {\n      var N, _, J, K;\n      B = s, H = c, V = 1;\n      L = -90, j = \"start\" === C ? c : \"middle\" === C ? c / 2 : 0, \"before\" === m ? (_ = b ? s : 0, J = (N = -u) - k, K = \"end\", E = s + X, M = \"hanging\") : (N = b ? 0 : s, J = (_ = s + u) + k, K = \"start\", E = -X, M = \"alphabetic\"), e.forEach(function (t) {\n        var e = O(t);\n        P.push({\n          x1: N,\n          y1: e,\n          x2: _,\n          y2: e,\n          text: T(t),\n          textX: J,\n          textY: e,\n          textHorizontalAlign: K,\n          textVerticalAlign: \"central\"\n        });\n      });\n    }\n    return {\n      width: B,\n      height: H,\n      gradientX1: 0,\n      gradientY1: V,\n      gradientX2: R,\n      gradientY2: 0,\n      colorStops: F,\n      ticks: P,\n      titleText: W,\n      titleX: E,\n      titleY: j,\n      titleRotation: L,\n      titleHorizontalAlign: C,\n      titleVerticalAlign: M\n    };\n  },\n  W = function (i) {\n    var n = i.scale,\n      r = i.ticks,\n      l = i.length,\n      a = void 0 === l ? y.length : l,\n      c = i.thickness,\n      s = void 0 === c ? y.thickness : c,\n      h = i.direction,\n      g = void 0 === h ? y.direction : h,\n      f = i.tickPosition,\n      m = void 0 === f ? y.tickPosition : f,\n      v = i.tickSize,\n      u = void 0 === v ? y.tickSize : v,\n      k = i.tickSpacing,\n      x = void 0 === k ? y.tickSpacing : k,\n      b = i.tickOverlap,\n      S = void 0 === b ? y.tickOverlap : b,\n      W = i.tickFormat,\n      z = void 0 === W ? y.tickFormat : W,\n      C = i.title,\n      w = i.titleAlign,\n      X = void 0 === w ? y.titleAlign : w,\n      Y = i.titleOffset,\n      O = A({\n        scale: n,\n        ticks: r,\n        length: a,\n        thickness: s,\n        direction: g,\n        tickPosition: m,\n        tickSize: u,\n        tickSpacing: x,\n        tickOverlap: S,\n        tickFormat: z,\n        title: C,\n        titleAlign: X,\n        titleOffset: void 0 === Y ? y.titleOffset : Y\n      }),\n      B = O.width,\n      H = O.height,\n      E = O.gradientX1,\n      j = O.gradientY1,\n      L = O.gradientX2,\n      M = O.gradientY2,\n      F = O.ticks,\n      T = O.colorStops,\n      P = O.titleText,\n      V = O.titleX,\n      R = O.titleY,\n      D = O.titleRotation,\n      q = O.titleVerticalAlign,\n      G = O.titleHorizontalAlign,\n      I = o(),\n      N = \"ContinuousColorsLegendSvgGradient.\" + g + \".\" + T.map(function (t) {\n        return t.offset;\n      }).join(\"_\");\n    return e(\"g\", {\n      children: [t(\"defs\", {\n        children: t(\"linearGradient\", {\n          id: N,\n          x1: E,\n          y1: j,\n          x2: L,\n          y2: M,\n          children: T.map(function (e) {\n            return t(\"stop\", p({}, e));\n          })\n        })\n      }), P && t(\"text\", {\n        transform: \"translate(\" + V + \", \" + R + \") rotate(\" + D + \")\",\n        textAnchor: G,\n        dominantBaseline: q,\n        style: I.legends.title.text,\n        children: P\n      }), t(\"rect\", {\n        width: B,\n        height: H,\n        fill: \"url(#\" + N\n      }), F.map(function (i, n) {\n        return e(d, {\n          children: [t(\"line\", {\n            x1: i.x1,\n            y1: i.y1,\n            x2: i.x2,\n            y2: i.y2,\n            style: I.legends.ticks.line\n          }), t(\"text\", {\n            x: i.textX,\n            y: i.textY,\n            textAnchor: i.textHorizontalAlign,\n            dominantBaseline: i.textVerticalAlign,\n            style: I.legends.ticks.text,\n            children: i.text\n          })]\n        }, n);\n      })]\n    });\n  },\n  z = [\"containerWidth\", \"containerHeight\", \"anchor\", \"translateX\", \"translateY\", \"length\", \"thickness\", \"direction\"],\n  C = function (e) {\n    var i,\n      n,\n      o = e.containerWidth,\n      r = e.containerHeight,\n      l = e.anchor,\n      a = e.translateX,\n      c = void 0 === a ? 0 : a,\n      d = e.translateY,\n      s = void 0 === d ? 0 : d,\n      h = e.length,\n      g = void 0 === h ? y.length : h,\n      f = e.thickness,\n      m = void 0 === f ? y.thickness : f,\n      v = e.direction,\n      u = void 0 === v ? y.direction : v,\n      k = function (t, e) {\n        if (null == t) return {};\n        var i,\n          n,\n          o = {},\n          r = Object.keys(t);\n        for (n = 0; n < r.length; n++) i = r[n], e.indexOf(i) >= 0 || (o[i] = t[i]);\n        return o;\n      }(e, z);\n    \"row\" === u ? (i = g, n = m) : (i = m, n = g);\n    var x = b({\n        anchor: l,\n        translateX: c,\n        translateY: s,\n        containerWidth: o,\n        containerHeight: r,\n        width: i,\n        height: n\n      }),\n      S = x.x,\n      A = x.y;\n    return t(\"g\", {\n      transform: \"translate(\" + S + \", \" + A + \")\",\n      children: t(W, p({\n        length: g,\n        thickness: m,\n        direction: u\n      }, k))\n    });\n  },\n  w = {\n    circle: f,\n    diamond: m,\n    square: v,\n    triangle: u\n  },\n  X = function (i) {\n    var n,\n      l,\n      a,\n      d,\n      g,\n      f,\n      m,\n      v,\n      u,\n      y,\n      k,\n      x = i.x,\n      b = i.y,\n      A = i.width,\n      W = i.height,\n      z = i.data,\n      C = i.direction,\n      X = void 0 === C ? \"left-to-right\" : C,\n      Y = i.justify,\n      O = void 0 !== Y && Y,\n      B = i.textColor,\n      H = i.background,\n      E = void 0 === H ? \"transparent\" : H,\n      j = i.opacity,\n      L = void 0 === j ? 1 : j,\n      M = i.symbolShape,\n      F = void 0 === M ? \"square\" : M,\n      T = i.symbolSize,\n      P = void 0 === T ? 16 : T,\n      V = i.symbolSpacing,\n      R = void 0 === V ? 8 : V,\n      D = i.symbolBorderWidth,\n      q = void 0 === D ? 0 : D,\n      G = i.symbolBorderColor,\n      I = void 0 === G ? \"transparent\" : G,\n      N = i.onClick,\n      _ = i.onMouseEnter,\n      J = i.onMouseLeave,\n      K = i.toggleSerie,\n      Q = i.effects,\n      U = s({}),\n      Z = U[0],\n      $ = U[1],\n      tt = o(),\n      et = h(function (t) {\n        if (Q) {\n          var e = Q.filter(function (t) {\n            return \"hover\" === t.on;\n          }).reduce(function (t, e) {\n            return p({}, t, e.style);\n          }, {});\n          $(e);\n        }\n        null == _ || _(z, t);\n      }, [_, z, Q]),\n      it = h(function (t) {\n        if (Q) {\n          var e = Q.filter(function (t) {\n            return \"hover\" !== t.on;\n          }).reduce(function (t, e) {\n            return p({}, t, e.style);\n          }, {});\n          $(e);\n        }\n        null == J || J(z, t);\n      }, [J, z, Q]),\n      nt = S({\n        direction: X,\n        justify: O,\n        symbolSize: null != (n = Z.symbolSize) ? n : P,\n        symbolSpacing: R,\n        width: A,\n        height: W\n      }),\n      ot = nt.symbolX,\n      rt = nt.symbolY,\n      lt = nt.labelX,\n      at = nt.labelY,\n      ct = nt.labelAnchor,\n      dt = nt.labelAlignment,\n      st = [N, _, J, K].some(function (t) {\n        return void 0 !== t;\n      }),\n      ht = \"function\" == typeof F ? F : w[F];\n    return e(\"g\", {\n      transform: \"translate(\" + x + \",\" + b + \")\",\n      style: {\n        opacity: null != (l = Z.itemOpacity) ? l : L\n      },\n      children: [t(\"rect\", {\n        width: A,\n        height: W,\n        fill: null != (a = Z.itemBackground) ? a : E,\n        style: {\n          cursor: st ? \"pointer\" : \"auto\"\n        },\n        onClick: function (t) {\n          null == N || N(z, t), null == K || K(z.id);\n        },\n        onMouseEnter: et,\n        onMouseLeave: it\n      }), c.createElement(ht, p({\n        id: z.id,\n        x: ot,\n        y: rt,\n        size: null != (d = Z.symbolSize) ? d : P,\n        fill: null != (g = null != (f = z.fill) ? f : z.color) ? g : \"black\",\n        borderWidth: null != (m = Z.symbolBorderWidth) ? m : q,\n        borderColor: null != (v = Z.symbolBorderColor) ? v : I\n      }, z.hidden ? tt.legends.hidden.symbol : void 0)), t(\"text\", {\n        textAnchor: ct,\n        style: p({}, r(tt.legends.text), {\n          fill: null != (u = null != (y = null != (k = Z.itemTextColor) ? k : B) ? y : tt.legends.text.fill) ? u : \"black\",\n          dominantBaseline: dt,\n          pointerEvents: \"none\",\n          userSelect: \"none\"\n        }, z.hidden ? tt.legends.hidden.text : void 0),\n        x: lt,\n        y: at,\n        children: z.label\n      })]\n    });\n  },\n  Y = function (e) {\n    var i = e.data,\n      n = e.x,\n      o = e.y,\n      r = e.direction,\n      l = e.padding,\n      a = void 0 === l ? 0 : l,\n      c = e.justify,\n      d = e.effects,\n      s = e.itemWidth,\n      h = e.itemHeight,\n      g = e.itemDirection,\n      f = void 0 === g ? \"left-to-right\" : g,\n      m = e.itemsSpacing,\n      v = void 0 === m ? 0 : m,\n      u = e.itemTextColor,\n      p = e.itemBackground,\n      y = void 0 === p ? \"transparent\" : p,\n      k = e.itemOpacity,\n      b = void 0 === k ? 1 : k,\n      S = e.symbolShape,\n      A = e.symbolSize,\n      W = e.symbolSpacing,\n      z = e.symbolBorderWidth,\n      C = e.symbolBorderColor,\n      w = e.onClick,\n      Y = e.onMouseEnter,\n      O = e.onMouseLeave,\n      B = e.toggleSerie,\n      H = x({\n        itemCount: i.length,\n        itemWidth: s,\n        itemHeight: h,\n        itemsSpacing: v,\n        direction: r,\n        padding: a\n      }).padding,\n      E = \"row\" === r ? s + v : 0,\n      j = \"column\" === r ? h + v : 0;\n    return t(\"g\", {\n      transform: \"translate(\" + n + \",\" + o + \")\",\n      children: i.map(function (e, i) {\n        return t(X, {\n          data: e,\n          x: i * E + H.left,\n          y: i * j + H.top,\n          width: s,\n          height: h,\n          direction: f,\n          justify: c,\n          effects: d,\n          textColor: u,\n          background: y,\n          opacity: b,\n          symbolShape: S,\n          symbolSize: A,\n          symbolSpacing: W,\n          symbolBorderWidth: z,\n          symbolBorderColor: C,\n          onClick: w,\n          onMouseEnter: Y,\n          onMouseLeave: O,\n          toggleSerie: B\n        }, i);\n      })\n    });\n  },\n  O = function (e) {\n    var i = e.data,\n      n = e.containerWidth,\n      o = e.containerHeight,\n      r = e.translateX,\n      l = void 0 === r ? 0 : r,\n      a = e.translateY,\n      c = void 0 === a ? 0 : a,\n      d = e.anchor,\n      s = e.direction,\n      h = e.padding,\n      g = void 0 === h ? 0 : h,\n      f = e.justify,\n      m = e.itemsSpacing,\n      v = void 0 === m ? 0 : m,\n      u = e.itemWidth,\n      p = e.itemHeight,\n      y = e.itemDirection,\n      k = e.itemTextColor,\n      S = e.itemBackground,\n      A = e.itemOpacity,\n      W = e.symbolShape,\n      z = e.symbolSize,\n      C = e.symbolSpacing,\n      w = e.symbolBorderWidth,\n      X = e.symbolBorderColor,\n      O = e.onClick,\n      B = e.onMouseEnter,\n      H = e.onMouseLeave,\n      E = e.toggleSerie,\n      j = e.effects,\n      L = x({\n        itemCount: i.length,\n        itemsSpacing: v,\n        itemWidth: u,\n        itemHeight: p,\n        direction: s,\n        padding: g\n      }),\n      M = L.width,\n      F = L.height,\n      T = b({\n        anchor: d,\n        translateX: l,\n        translateY: c,\n        containerWidth: n,\n        containerHeight: o,\n        width: M,\n        height: F\n      }),\n      P = T.x,\n      V = T.y;\n    return t(Y, {\n      data: i,\n      x: P,\n      y: V,\n      direction: s,\n      padding: g,\n      justify: f,\n      effects: j,\n      itemsSpacing: v,\n      itemWidth: u,\n      itemHeight: p,\n      itemDirection: y,\n      itemTextColor: k,\n      itemBackground: S,\n      itemOpacity: A,\n      symbolShape: W,\n      symbolSize: z,\n      symbolSpacing: C,\n      symbolBorderWidth: w,\n      symbolBorderColor: X,\n      onClick: O,\n      onMouseEnter: B,\n      onMouseLeave: H,\n      toggleSerie: \"boolean\" == typeof E ? void 0 : E\n    });\n  },\n  B = {\n    start: \"left\",\n    middle: \"center\",\n    end: \"right\"\n  },\n  H = function (t, e) {\n    var i = e.data,\n      n = e.containerWidth,\n      o = e.containerHeight,\n      r = e.translateX,\n      l = void 0 === r ? 0 : r,\n      a = e.translateY,\n      c = void 0 === a ? 0 : a,\n      d = e.anchor,\n      s = e.direction,\n      h = e.padding,\n      g = void 0 === h ? 0 : h,\n      f = e.justify,\n      m = void 0 !== f && f,\n      v = e.itemsSpacing,\n      u = void 0 === v ? 0 : v,\n      p = e.itemWidth,\n      y = e.itemHeight,\n      k = e.itemDirection,\n      A = void 0 === k ? \"left-to-right\" : k,\n      W = e.itemTextColor,\n      z = e.symbolSize,\n      C = void 0 === z ? 16 : z,\n      w = e.symbolSpacing,\n      X = void 0 === w ? 8 : w,\n      Y = e.theme,\n      O = x({\n        itemCount: i.length,\n        itemWidth: p,\n        itemHeight: y,\n        itemsSpacing: u,\n        direction: s,\n        padding: g\n      }),\n      H = O.width,\n      E = O.height,\n      j = O.padding,\n      L = b({\n        anchor: d,\n        translateX: l,\n        translateY: c,\n        containerWidth: n,\n        containerHeight: o,\n        width: H,\n        height: E\n      }),\n      M = L.x,\n      F = L.y,\n      T = \"row\" === s ? p + u : 0,\n      P = \"column\" === s ? y + u : 0;\n    t.save(), t.translate(M, F), t.font = Y.legends.text.fontSize + \"px \" + (Y.legends.text.fontFamily || \"sans-serif\"), i.forEach(function (e, i) {\n      var n,\n        o,\n        r = i * T + j.left,\n        l = i * P + j.top,\n        a = S({\n          direction: A,\n          justify: m,\n          symbolSize: C,\n          symbolSpacing: X,\n          width: p,\n          height: y\n        }),\n        c = a.symbolX,\n        d = a.symbolY,\n        s = a.labelX,\n        h = a.labelY,\n        g = a.labelAnchor,\n        f = a.labelAlignment;\n      t.fillStyle = null != (n = e.color) ? n : \"black\", t.fillRect(r + c, l + d, C, C), t.textAlign = B[g], \"central\" === f && (t.textBaseline = \"middle\"), t.fillStyle = null != (o = null != W ? W : Y.legends.text.fill) ? o : \"black\", t.fillText(String(e.label), r + s, l + h);\n    }), t.restore();\n  },\n  E = function (t, e) {\n    var i = e.containerWidth,\n      n = e.containerHeight,\n      o = e.anchor,\n      r = e.translateX,\n      a = void 0 === r ? 0 : r,\n      c = e.translateY,\n      d = void 0 === c ? 0 : c,\n      s = e.scale,\n      h = e.length,\n      g = void 0 === h ? y.length : h,\n      f = e.thickness,\n      m = void 0 === f ? y.thickness : f,\n      v = e.direction,\n      u = void 0 === v ? y.direction : v,\n      p = e.ticks,\n      k = e.tickPosition,\n      x = void 0 === k ? y.tickPosition : k,\n      S = e.tickSize,\n      W = void 0 === S ? y.tickSize : S,\n      z = e.tickSpacing,\n      C = void 0 === z ? y.tickSpacing : z,\n      w = e.tickOverlap,\n      X = void 0 === w ? y.tickOverlap : w,\n      Y = e.tickFormat,\n      O = void 0 === Y ? y.tickFormat : Y,\n      B = e.title,\n      H = e.titleAlign,\n      E = void 0 === H ? y.titleAlign : H,\n      j = e.titleOffset,\n      L = void 0 === j ? y.titleOffset : j,\n      M = e.theme,\n      F = A({\n        scale: s,\n        ticks: p,\n        length: g,\n        thickness: m,\n        direction: u,\n        tickPosition: x,\n        tickSize: W,\n        tickSpacing: C,\n        tickOverlap: X,\n        tickFormat: O,\n        title: B,\n        titleAlign: E,\n        titleOffset: L\n      }),\n      T = F.width,\n      P = F.height,\n      V = F.gradientX1,\n      R = F.gradientY1,\n      D = F.gradientX2,\n      q = F.gradientY2,\n      G = F.colorStops,\n      I = F.ticks,\n      N = F.titleText,\n      _ = F.titleX,\n      J = F.titleY,\n      K = F.titleRotation,\n      Q = F.titleVerticalAlign,\n      U = F.titleHorizontalAlign,\n      Z = b({\n        anchor: o,\n        translateX: a,\n        translateY: d,\n        containerWidth: i,\n        containerHeight: n,\n        width: T,\n        height: P\n      }),\n      $ = Z.x,\n      tt = Z.y,\n      et = {\n        font: t.font,\n        textAlign: t.textAlign,\n        textBaseline: t.textBaseline\n      };\n    t.save(), t.translate($, tt);\n    var it = t.createLinearGradient(V * T, R * P, D * T, q * P);\n    G.forEach(function (t) {\n      it.addColorStop(t.offset, t.stopColor);\n    }), t.fillStyle = it, t.fillRect(0, 0, T, P), t.font = (M.legends.ticks.text.fontWeight ? M.legends.ticks.text.fontWeight + \" \" : \"\") + M.legends.ticks.text.fontSize + \"px \" + M.legends.ticks.text.fontFamily, I.forEach(function (e) {\n      var i;\n      (null != (i = M.legends.ticks.line.strokeWidth) ? i : 0) > 0 && (t.lineWidth = Number(M.axis.ticks.line.strokeWidth), M.axis.ticks.line.stroke && (t.strokeStyle = M.axis.ticks.line.stroke), t.lineCap = \"square\", t.beginPath(), t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.stroke()), M.legends.ticks.text.fill && (t.fillStyle = M.legends.ticks.text.fill), t.textAlign = \"middle\" === e.textHorizontalAlign ? \"center\" : e.textHorizontalAlign, t.textBaseline = \"central\" === e.textVerticalAlign ? \"middle\" : e.textVerticalAlign, t.fillText(e.text, e.textX, e.textY);\n    }), N && (t.save(), t.translate(_, J), t.rotate(l(K)), t.font = (M.legends.title.text.fontWeight ? M.legends.title.text.fontWeight + \" \" : \"\") + M.legends.title.text.fontSize + \"px \" + M.legends.title.text.fontFamily, M.legends.title.text.fill && (t.fillStyle = M.legends.title.text.fill), t.textAlign = \"middle\" === U ? \"center\" : U, t.textBaseline = Q, t.fillText(N, 0, 0), t.restore()), t.restore(), t.font = et.font, t.textAlign = et.textAlign, t.textBaseline = et.textBaseline;\n  },\n  j = function (t) {\n    var e = t.scale,\n      i = t.domain,\n      n = t.reverse,\n      o = void 0 !== n && n,\n      r = t.valueFormat,\n      l = void 0 === r ? function (t) {\n        return t;\n      } : r,\n      a = t.separator,\n      c = void 0 === a ? \" - \" : a;\n    return g(function () {\n      var t = (null != i ? i : e.range()).map(function (t, i) {\n        var n = e.invertExtent(t),\n          o = n[0],\n          r = n[1];\n        return {\n          id: t,\n          index: i,\n          extent: [o, r],\n          label: \"\" + l(o) + c + l(r),\n          value: e(o),\n          color: t\n        };\n      });\n      return o && t.reverse(), t;\n    }, [i, e, o, c, l]);\n  };\nexport { C as AnchoredContinuousColorsLegendSvg, O as BoxLegendSvg, W as ContinuousColorsLegendSvg, Y as LegendSvg, X as LegendSvgItem, f as SymbolCircle, m as SymbolDiamond, v as SymbolSquare, u as SymbolTriangle, A as computeContinuousColorsLegend, x as computeDimensions, S as computeItemLayout, b as computePositionFromAnchor, y as continuousColorsLegendDefaults, E as renderContinuousColorLegendToCanvas, H as renderLegendToCanvas, j as useQuantizeColorScaleLegendData };\n//# sourceMappingURL=nivo-legends.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}