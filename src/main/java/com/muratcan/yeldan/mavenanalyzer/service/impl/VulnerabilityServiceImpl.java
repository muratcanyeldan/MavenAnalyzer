package com.muratcan.yeldan.mavenanalyzer.service.impl;

import com.muratcan.yeldan.mavenanalyzer.config.DynamicCacheProperties;
import com.muratcan.yeldan.mavenanalyzer.dto.ossindex.OssIndexRequest;
import com.muratcan.yeldan.mavenanalyzer.dto.ossindex.OssIndexResponse;
import com.muratcan.yeldan.mavenanalyzer.dto.ossindex.OssIndexVulnerability;
import com.muratcan.yeldan.mavenanalyzer.dto.response.AppSettingsResponse;
import com.muratcan.yeldan.mavenanalyzer.dto.response.VulnerabilityResponse;
import com.muratcan.yeldan.mavenanalyzer.entity.Dependency;
import com.muratcan.yeldan.mavenanalyzer.entity.DependencyAnalysis;
import com.muratcan.yeldan.mavenanalyzer.entity.Project;
import com.muratcan.yeldan.mavenanalyzer.entity.Vulnerability;
import com.muratcan.yeldan.mavenanalyzer.repository.DependencyAnalysisRepository;
import com.muratcan.yeldan.mavenanalyzer.repository.DependencyRepository;
import com.muratcan.yeldan.mavenanalyzer.repository.VulnerabilityRepository;
import com.muratcan.yeldan.mavenanalyzer.service.AppSettingsService;
import com.muratcan.yeldan.mavenanalyzer.service.VulnerabilityService;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ArrayUtils;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@Slf4j
public class VulnerabilityServiceImpl implements VulnerabilityService {

    private static final String SEVERITY_CRITICAL = "CRITICAL";
    private static final String SEVERITY_HIGH = "HIGH";
    private static final String SEVERITY_MEDIUM = "MEDIUM";
    private static final String SEVERITY_LOW = "LOW";
    private static final String SEVERITY_UNKNOWN = "UNKNOWN";

    private final RestTemplate restTemplate;
    private final DependencyRepository dependencyRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final DependencyAnalysisRepository dependencyAnalysisRepository;
    private final AppSettingsService appSettingsService;

    private final ObjectProvider<VulnerabilityService> vulnerabilityServiceProvider;
    private final Random random = new Random();
    private final DynamicCacheProperties cacheProperties;

    @Value("${vulnerability.ossindex.api.url.unauthorized:https://ossindex.sonatype.org/api/v3/component-report}")
    private String unauthorizedApiUrl;
    @Value("${vulnerability.ossindex.api.url.authorized:https://ossindex.sonatype.org/api/v3/authorized/component-report}")
    private String authorizedApiUrl;
    @Value("${vulnerability.ossindex.auth.enabled:false}")
    private boolean authEnabled;
    @Value("${vulnerability.ossindex.auth.username:}")
    private String ossIndexUsername;
    @Value("${vulnerability.ossindex.auth.token:}")
    private String ossIndexToken;
    @Value("${vulnerability.batch.size:20}")
    private int batchSize;
    @Value("${vulnerability.mock.enabled:true}")
    private boolean mockEnabled;
    @PersistenceContext
    private EntityManager entityManager;

    public VulnerabilityServiceImpl(
            RestTemplate restTemplate,
            DependencyRepository dependencyRepository,
            VulnerabilityRepository vulnerabilityRepository,
            DependencyAnalysisRepository dependencyAnalysisRepository,
            AppSettingsService appSettingsService,
            ObjectProvider<VulnerabilityService> vulnerabilityServiceProvider,
            DynamicCacheProperties cacheProperties) {
        this.restTemplate = restTemplate;
        this.dependencyRepository = dependencyRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.dependencyAnalysisRepository = dependencyAnalysisRepository;
        this.appSettingsService = appSettingsService;
        this.vulnerabilityServiceProvider = vulnerabilityServiceProvider;
        this.cacheProperties = cacheProperties;
    }

    private VulnerabilityService getProxiedSelf() {
        return vulnerabilityServiceProvider.getObject();
    }

    /**
     * Check for vulnerabilities in a specific Maven dependency
     *
     * @param groupId    The Maven group ID
     * @param artifactId The Maven artifact ID
     * @param version    The version of the dependency
     * @return List of vulnerabilities found
     */
    @Override
    @Cacheable(value = "vulnerabilities", key = "#groupId + ':' + #artifactId + ':' + #version",
            condition = "#root.target.cacheProperties.vulnerabilityCacheEnabled")
    public List<VulnerabilityResponse> checkVulnerabilities(String groupId, String artifactId, String version) {
        if (mockEnabled) {
            log.info("Mock mode enabled. Generating mock vulnerabilities for {}:{}:{}", groupId, artifactId, version);
            return generateMockVulnerabilities(artifactId, version);
        }

        try {
            log.info("Checking vulnerabilities for {}:{}:{}", groupId, artifactId, version);

            String packageCoordinates = String.format("pkg:maven/%s/%s@%s", groupId, artifactId, version);

            List<DependencyCoordinates> dependencies = Collections.singletonList(
                    new DependencyCoordinates(groupId, artifactId, version)
            );

            Map<String, List<VulnerabilityResponse>> batchResults = checkVulnerabilitiesBatch(dependencies);

            String key = groupId + ":" + artifactId + ":" + version;
            List<VulnerabilityResponse> vulnerabilities = batchResults.getOrDefault(key, new ArrayList<>());

            log.debug("Retrieved {} vulnerabilities for {}:{}:{} from OSS Index API",
                    vulnerabilities.size(), groupId, artifactId, version);

            return vulnerabilities;
        } catch (Exception e) {
            log.error("Error checking vulnerabilities for {}:{}:{}", groupId, artifactId, version, e);
            return new ArrayList<>();
        }
    }

    /**
     * Asynchronously check for vulnerabilities in a specific Maven dependency
     *
     * @param groupId    The Maven group ID
     * @param artifactId The Maven artifact ID
     * @param version    The version of the dependency
     * @param analysisId The ID of the analysis this check is part of
     * @return A CompletableFuture that will be completed with the list of vulnerabilities found
     */
    @Override
    @Async("taskExecutor")
    @Transactional
    public CompletableFuture<List<VulnerabilityResponse>> checkVulnerabilitiesAsync(
            String groupId, String artifactId, String version, Long analysisId) {
        long startTime = System.currentTimeMillis();
        log.info("Asynchronously checking vulnerabilities for {}:{}:{} (Analysis ID: {})",
                groupId, artifactId, version, analysisId);

        try {
            List<VulnerabilityResponse> vulnerabilities = getProxiedSelf().checkVulnerabilities(groupId, artifactId, version);
            long apiCheckTime = System.currentTimeMillis();

            log.info("Found {} vulnerabilities for {}:{}:{} in {} ms",
                    vulnerabilities.size(), groupId, artifactId, version, (apiCheckTime - startTime));

            getProxiedSelf().updateDependencyVulnerabilities(groupId, artifactId, version, analysisId, vulnerabilities);
            long updateTime = System.currentTimeMillis();
            log.info("Updated dependency vulnerabilities for {}:{}:{} in {} ms",
                    groupId, artifactId, version, (updateTime - apiCheckTime));

            getProxiedSelf().checkAndUpdateAnalysisStatus(analysisId);
            long totalTime = System.currentTimeMillis() - startTime;

            log.info("Completed vulnerability check for {}:{}:{} (Analysis ID: {}) in {} ms",
                    groupId, artifactId, version, analysisId, totalTime);

            return CompletableFuture.completedFuture(vulnerabilities);
        } catch (Exception e) {
            log.error("Error in async vulnerability check for {}:{}:{}", groupId, artifactId, version, e);
            getProxiedSelf().checkAndUpdateAnalysisStatus(analysisId);
            return CompletableFuture.completedFuture(new ArrayList<>());
        }
    }

    @Override
    @Transactional
    public void updateDependencyVulnerabilities(
            String groupId, String artifactId, String version, Long analysisId,
            List<VulnerabilityResponse> vulnerabilities) {

        try {
            Dependency dependency = dependencyRepository.findByAnalysisIdAndGroupIdAndArtifactIdAndCurrentVersion(
                            analysisId, groupId, artifactId, version)
                    .orElse(null);

            if (dependency == null) {
                log.warn("Dependency {}:{}:{} not found for analysis ID: {}",
                        groupId, artifactId, version, analysisId);
                return;
            }

            boolean isVulnerable = !vulnerabilities.isEmpty();
            dependency.setIsVulnerable(isVulnerable);
            dependency.setVulnerableCount(vulnerabilities.size());

            dependencyRepository.save(dependency);

            if (isVulnerable) {
                for (VulnerabilityResponse vulnResponse : vulnerabilities) {
                    Vulnerability vulnerability = Vulnerability.builder()
                            .dependency(dependency)
                            .name(vulnResponse.getName())
                            .description(vulnResponse.getDescription())
                            .severity(vulnResponse.getSeverity())
                            .affectedVersions(vulnResponse.getAffectedVersions())
                            .fixedInVersion(vulnResponse.getFixedInVersion())
                            .build();

                    vulnerabilityRepository.save(vulnerability);
                }

                log.info("Added {} vulnerabilities for {}:{}:{}",
                        vulnerabilities.size(), groupId, artifactId, version);
            }
        } catch (Exception e) {
            log.error("Error updating dependency vulnerabilities for {}:{}:{}",
                    groupId, artifactId, version, e);
        }
    }

    @Override
    @Transactional
    public void checkAndUpdateAnalysisStatus(Long analysisId) {
        try {
            DependencyAnalysis analysis = dependencyAnalysisRepository.findById(analysisId)
                    .orElse(null);

            if (analysis == null) {
                log.warn("Analysis not found with ID: {}", analysisId);
                return;
            }

            if (analysis.getVulnerabilityCheckStatus() == DependencyAnalysis.VulnerabilityCheckStatus.IN_PROGRESS) {
                long processedCount = dependencyRepository.countByAnalysisIdAndVulnerableStatusSet(analysisId);
                int totalDependencies = analysis.getTotalDependencies();

                log.info("Vulnerability check status: Processed {}/{} dependencies for analysis ID: {}",
                        processedCount, totalDependencies, analysisId);

                if (processedCount >= totalDependencies) {
                    analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
                    dependencyAnalysisRepository.save(analysis);
                    log.info("All dependencies processed for vulnerabilities. Analysis ID: {} marked as COMPLETED", analysisId);

                    if (analysis.isNotifyOnCompletion()) {
                        sendCompletionNotification(analysis);
                    }
                } else {
                    log.debug("Vulnerability check still in progress. Processed {}/{} dependencies for analysis ID: {}",
                            processedCount, totalDependencies, analysisId);
                }
            } else {
                log.debug("Analysis ID: {} is not in IN_PROGRESS state (current state: {})",
                        analysisId, analysis.getVulnerabilityCheckStatus());
            }
        } catch (Exception e) {
            log.error("Error checking and updating analysis status for ID: {}", analysisId, e);
            try {
                DependencyAnalysis analysis = dependencyAnalysisRepository.findById(analysisId).orElse(null);
                if (analysis != null && analysis.getVulnerabilityCheckStatus() == DependencyAnalysis.VulnerabilityCheckStatus.IN_PROGRESS) {
                    analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
                    dependencyAnalysisRepository.save(analysis);
                    log.info("Force updated analysis ID: {} to COMPLETED after error", analysisId);
                }
            } catch (Exception ex) {
                log.error("Failed to recover analysis status for ID: {}", analysisId, ex);
            }
        }
    }

    private void sendCompletionNotification(DependencyAnalysis analysis) {
        try {
            AppSettingsResponse settings = appSettingsService.getSettings();
            if (!Boolean.TRUE.equals(settings.getShowNotifications())) {
                log.debug("Notifications are disabled globally, skipping completion notification for analysis ID: {}", analysis.getId());
                return;
            }

            log.info("Sending analysis completion notification for analysis ID: {}", analysis.getId());

            Project project = analysis.getProject();
            String projectName = project != null ? project.getName() : "Standalone Analysis";

            long vulnerableCount = analysis.getDependencies().stream()
                    .filter(d -> d.getIsVulnerable() != null && d.getIsVulnerable())
                    .count();

            String notificationMessage = String.format(
                    "Analysis completed for %s. Found %d dependencies (%d outdated, %d vulnerable).",
                    projectName,
                    analysis.getTotalDependencies(),
                    analysis.getOutdatedDependencies(),
                    vulnerableCount
            );

            // In a real implementation, this would send a system notification, email, or push notification
            // For demo purposes, we'll just log it
            log.info("NOTIFICATION: {}", notificationMessage);

            // If you had a notification service, you would inject and call it here:
            // notificationService.sendNotification(analysis.getProject(), "Analysis Complete", notificationMessage);
        } catch (Exception e) {
            log.error("Error sending completion notification for analysis ID: {}", analysis.getId(), e);
        }
    }

    private List<VulnerabilityResponse> generateMockVulnerabilities(String artifactId, String version) {
        try {
            Thread.sleep(300);

            if (artifactId.contains("log4j") && version.startsWith("2")) {
                List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();

                if (version.matches("2\\.(0|1|2|3|4|5|6|7|8|9|10|11|12|13|14).*")) {
                    vulnerabilities.add(VulnerabilityResponse.builder()
                            .name("CVE-2021-44228")
                            .description("Log4j2 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. This allows an unauthenticated attacker to execute arbitrary code.")
                            .severity(SEVERITY_CRITICAL)
                            .affectedVersions("2.0-beta9 to 2.14.1")
                            .fixedInVersion("2.15.0")
                            .build());
                }

                if (version.matches("2\\.(0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15).*")) {
                    vulnerabilities.add(VulnerabilityResponse.builder()
                            .name("CVE-2021-45046")
                            .description("The fix for CVE-2021-44228 was incomplete in certain non-default configurations.")
                            .severity(SEVERITY_HIGH)
                            .affectedVersions("2.0-beta9 to 2.15.0")
                            .fixedInVersion("2.16.0")
                            .build());
                }

                return vulnerabilities;
            }

            if (artifactId.contains("spring-core") && version.matches("5\\.(0|1|2|3\\.[0-8]).*")) {
                List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();
                vulnerabilities.add(VulnerabilityResponse.builder()
                        .name("CVE-2022-22965")
                        .description("Spring Framework RCE via Data Binding on JDK 9+")
                        .severity(SEVERITY_CRITICAL)
                        .affectedVersions("5.3.0 to 5.3.17, 5.2.0 to 5.2.19, and older")
                        .fixedInVersion("5.3.18+ and 5.2.20+")
                        .build());
                return vulnerabilities;
            }

            if (artifactId.contains("commons-text") && version.matches("1\\.[0-9]\\.[0-9]")) {
                List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();
                vulnerabilities.add(VulnerabilityResponse.builder()
                        .name("CVE-2022-42889")
                        .description("Apache Commons Text's default string interpolation can lead to RCE in applications using defaults.")
                        .severity(SEVERITY_HIGH)
                        .affectedVersions("1.5.0 to 1.9.0")
                        .fixedInVersion("1.10.0")
                        .build());
                return vulnerabilities;
            }

            if (random.nextInt(100) < 25) {
                List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();

                vulnerabilities.add(VulnerabilityResponse.builder()
                        .name("CVE-" + (2021 + random.nextInt(2)) + "-" + (10000 + random.nextInt(9999)))
                        .description("Security vulnerability in " + artifactId + " allows attackers to " +
                                getRandomVulnerabilityImpact() + " through " + getRandomVulnerabilityVector())
                        .severity(getRandomSeverity())
                        .affectedVersions("<" + version)
                        .fixedInVersion(getIncrementedVersion(version))
                        .build());

                if (random.nextInt(10) < 3) {
                    vulnerabilities.add(VulnerabilityResponse.builder()
                            .name("CVE-" + (2020 + random.nextInt(3)) + "-" + (10000 + random.nextInt(9999)))
                            .description("Another security issue found in " + artifactId + " that could allow " +
                                    getRandomVulnerabilityImpact())
                            .severity(getRandomSeverity())
                            .affectedVersions("<" + version)
                            .fixedInVersion(getIncrementedVersion(version))
                            .build());
                }

                return vulnerabilities;
            }

            return new ArrayList<>();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Thread interrupted", e);
            return new ArrayList<>();
        }
    }

    private String getRandomVulnerabilityImpact() {
        String[] impacts = {
                "execute arbitrary code",
                "bypass authentication",
                "access sensitive information",
                "cause a denial of service",
                "elevate privileges",
                "modify data",
                "bypass security controls",
                "inject malicious code",
                "perform remote code execution",
                "read restricted files"
        };
        return impacts[random.nextInt(impacts.length)];
    }

    private String getRandomVulnerabilityVector() {
        String[] vectors = {
                "improper input validation",
                "insufficient access control",
                "insecure deserialization",
                "buffer overflow",
                "integer overflow",
                "SQL injection",
                "XSS (cross-site scripting)",
                "CSRF (cross-site request forgery)",
                "race condition",
                "path traversal"
        };
        return vectors[random.nextInt(vectors.length)];
    }

    private String getIncrementedVersion(String version) {
        try {
            // Simple version incrementing for x.y.z format
            String[] parts = version.split("\\.");
            if (parts.length >= 3) {
                int patch = Integer.parseInt(parts[2]) + 1;
                return parts[0] + "." + parts[1] + "." + patch;
            } else if (parts.length == 2) {
                return parts[0] + "." + parts[1] + ".1";
            } else {
                return version + ".1";
            }
        } catch (Exception e) {
            // If parsing fails, just append .1
            return version + ".1";
        }
    }

    /**
     * Get a random severity level for mock vulnerabilities
     */
    private String getRandomSeverity() {
        String[] severities = {SEVERITY_LOW, SEVERITY_MEDIUM, SEVERITY_HIGH, SEVERITY_CRITICAL};
        return severities[random.nextInt(severities.length)];
    }

    /**
     * Convert a CVSS score to a severity string
     *
     * @param cvssScore The CVSS score (0.0-10.0)
     * @return The severity string (LOW, MEDIUM, HIGH, CRITICAL)
     */
    private String getSeverityFromCvssScore(Float cvssScore) {
        if (cvssScore == null) {
            return SEVERITY_UNKNOWN;
        }

        if (cvssScore >= 9.0) {
            return SEVERITY_CRITICAL;
        } else if (cvssScore >= 7.0) {
            return SEVERITY_HIGH;
        } else if (cvssScore >= 4.0) {
            return SEVERITY_MEDIUM;
        } else {
            return SEVERITY_LOW;
        }
    }

    /**
     * Manually clear the cache for a specific dependency
     *
     * @param groupId    The Maven group ID
     * @param artifactId The Maven artifact ID
     * @param version    The version of the dependency
     */
    @Override
    @CacheEvict(value = {"vulnerabilities", "vulnerabilityCounts"},
            key = "#groupId + ':' + #artifactId + ':' + #version")
    public void clearVulnerabilityCache(String groupId, String artifactId, String version) {
        log.info("Cleared vulnerability cache for {}:{}:{}", groupId, artifactId, version);
    }

    @Override
    @CacheEvict(value = {"vulnerabilities", "vulnerabilityCounts"}, allEntries = true)
    public void clearAllVulnerabilityCaches() {
        log.info("Cleared all vulnerability caches");
    }

    /**
     * Helper method to get the OSS Index API URL based on auth settings
     *
     * @return the appropriate API URL
     */
    private String getApiUrl() {
        return authEnabled ? authorizedApiUrl : unauthorizedApiUrl;
    }

    /**
     * Prepare headers for OSS Index API calls, including authentication if enabled
     *
     * @return HttpHeaders with appropriate content type and auth
     */
    private HttpHeaders prepareHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        if (authEnabled && ossIndexUsername != null && !ossIndexUsername.isEmpty()
                && ossIndexToken != null && !ossIndexToken.isEmpty()) {

            String auth = ossIndexUsername + ":" + ossIndexToken;
            byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes(StandardCharsets.UTF_8));
            String authHeader = "Basic " + new String(encodedAuth);
            headers.set("Authorization", authHeader);

            log.debug("Added authentication headers for OSS Index API");
        }

        return headers;
    }

    private Map<String, List<VulnerabilityResponse>> checkVulnerabilitiesBatch(
            List<DependencyCoordinates> dependencies) {

        if (dependencies.isEmpty()) {
            return Collections.emptyMap();
        }

        if (mockEnabled) {
            return generateMockVulnerabilityBatch(dependencies);
        }

        try {
            log.info("Checking vulnerabilities in batch for {} dependencies", dependencies.size());
            
            List<String> coordinates = formatDependenciesForOssIndex(dependencies);
            OssIndexResponse[] ossResponses = sendOssIndexRequest(coordinates);
            Map<String, List<VulnerabilityResponse>> result = initializeResultMap(dependencies);
            
            if (ArrayUtils.isNotEmpty(ossResponses)) {
                processOssIndexResponses(ossResponses, result);
            }

            return result;
        } catch (Exception e) {
            log.error("Error checking vulnerabilities in batch for {} dependencies", dependencies.size(), e);
            return createEmptyResultMap(dependencies);
        }
    }

    private Map<String, List<VulnerabilityResponse>> generateMockVulnerabilityBatch(
            List<DependencyCoordinates> dependencies) {
        log.info("Mock mode enabled. Generating mock vulnerabilities for {} dependencies", dependencies.size());
        Map<String, List<VulnerabilityResponse>> result = new HashMap<>();

        for (DependencyCoordinates dep : dependencies) {
            String key = formatDependencyKey(dep);
            result.put(key, generateMockVulnerabilities(dep.getArtifactId(), dep.getVersion()));
        }

        return result;
    }

    private String formatDependencyKey(DependencyCoordinates dep) {
        return dep.getGroupId() + ":" + dep.getArtifactId() + ":" + dep.getVersion();
    }

    private List<String> formatDependenciesForOssIndex(List<DependencyCoordinates> dependencies) {
        return dependencies.stream()
                .map(dep -> String.format("pkg:maven/%s/%s@%s",
                        dep.getGroupId(), dep.getArtifactId(), dep.getVersion()))
                .collect(Collectors.toList());
    }

    private OssIndexResponse[] sendOssIndexRequest(List<String> coordinates) {
        try {
            OssIndexRequest request = OssIndexRequest.builder()
                    .coordinates(coordinates)
                    .build();

            HttpHeaders headers = prepareHeaders();
            HttpEntity<OssIndexRequest> entity = new HttpEntity<>(request, headers);

            ResponseEntity<OssIndexResponse[]> response = restTemplate.postForEntity(
                    getApiUrl(),
                    entity,
                    OssIndexResponse[].class
            );

            return response.getBody();
        } catch (Exception e) {
            log.error("Error sending request to OSS Index API", e);
            return new OssIndexResponse[0];
        }
    }

    private Map<String, List<VulnerabilityResponse>> initializeResultMap(List<DependencyCoordinates> dependencies) {
        Map<String, List<VulnerabilityResponse>> result = new HashMap<>();
        for (DependencyCoordinates dep : dependencies) {
            result.put(formatDependencyKey(dep), new ArrayList<>());
        }
        return result;
    }

    private Map<String, List<VulnerabilityResponse>> createEmptyResultMap(List<DependencyCoordinates> dependencies) {
        return initializeResultMap(dependencies);
    }

    private void processOssIndexResponses(OssIndexResponse[] ossResponses, Map<String, List<VulnerabilityResponse>> result) {
        for (OssIndexResponse ossResponse : ossResponses) {
            try {
                DependencyCoordinates depCoordinates = parseOssIndexCoordinates(ossResponse.getCoordinates());
                if (depCoordinates == null) {
                    continue;
                }
                
                String key = formatDependencyKey(depCoordinates);
                
                List<VulnerabilityResponse> vulnerabilities = convertOssIndexVulnerabilities(
                        ossResponse.getVulnerabilities(),
                        depCoordinates.getGroupId(),
                        depCoordinates.getArtifactId(),
                        depCoordinates.getVersion()
                );
                
                addVulnerabilitiesToResult(result, key, vulnerabilities,
                        depCoordinates.getGroupId(), 
                        depCoordinates.getArtifactId(), 
                        depCoordinates.getVersion());
            } catch (Exception e) {
                log.warn("Error processing OSS Index response: {}", e.getMessage());
            }
        }
    }

    private DependencyCoordinates parseOssIndexCoordinates(String coord) {
        log.debug("Processing OssIndexResponse with coordinates: {}", coord);

        String cleanCoord = coord.replaceAll("\\s+\\(.*\\)$", "");

        String[] parts = cleanCoord.replace("pkg:maven/", "").split("@");
        if (parts.length != 2) {
            log.warn("Invalid coordinate format: {}", coord);
            return null;
        }

        String groupArtifact = parts[0];
        String version = parts[1];

        String[] groupArtParts = groupArtifact.split("/");
        if (groupArtParts.length != 2) {
            log.warn("Invalid groupId/artifactId format: {}", groupArtifact);
            return null;
        }

        String groupId = groupArtParts[0];
        String artifactId = groupArtParts[1];
        
        return new DependencyCoordinates(groupId, artifactId, version);
    }

    private List<VulnerabilityResponse> convertOssIndexVulnerabilities(
            List<OssIndexVulnerability> ossVulnerabilities,
            String groupId, String artifactId, String version) {
        
        if (ossVulnerabilities == null || ossVulnerabilities.isEmpty()) {
            return Collections.emptyList();
        }
        
        List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();
        
        for (OssIndexVulnerability ossVuln : ossVulnerabilities) {
            vulnerabilities.add(VulnerabilityResponse.builder()
                    .name(ossVuln.getCve() != null ? ossVuln.getCve() : ossVuln.getId())
                    .description(ossVuln.getDescription())
                    .severity(getSeverityFromCvssScore(ossVuln.getCvssScore()))
                    .affectedVersions(ossVuln.getVersionRanges())
                    .fixedInVersion("Not specified")
                    .build());
        }

        log.info("Found {} vulnerabilities for {}:{}:{} from OssIndex API",
                vulnerabilities.size(), groupId, artifactId, version);
                
        return vulnerabilities;
    }

    private void addVulnerabilitiesToResult(
            Map<String, List<VulnerabilityResponse>> result, 
            String key, 
            List<VulnerabilityResponse> vulnerabilities,
            String groupId, String artifactId, String version) {
            
        List<VulnerabilityResponse> existingVulns = result.get(key);
        if (existingVulns != null) {
            existingVulns.addAll(vulnerabilities);
            log.debug("Merged {} vulnerabilities into existing list for {}:{}:{}",
                    vulnerabilities.size(), groupId, artifactId, version);
        } else {
            result.put(key, vulnerabilities);
        }

        log.debug("Retrieved {} vulnerabilities for {}:{}:{} from OSS Index API",
                vulnerabilities.size(), groupId, artifactId, version);
    }

    /**
     * Process all dependencies for an analysis in batches and check for vulnerabilities
     * This is more efficient than checking each dependency individually
     *
     * @param analysisId The ID of the analysis to process
     */
    @Override
    @Async("taskExecutor")
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void processDependenciesInBatches(Long analysisId) {
        log.info("Starting batch processing of vulnerabilities for analysis ID: {}", analysisId);

        DependencyAnalysis analysis = null;
        int maxRetries = 5;
        int retryCount = 0;
        int retryDelayMs = 2000;

        while (analysis == null && retryCount < maxRetries) {
            try {
                analysis = getProxiedSelf().getAnalysisWithFreshTransaction(analysisId);

                if (analysis == null) {
                    retryCount++;
                    log.info("Transaction boundary issue: Analysis ID: {} not found yet. Retry attempt {}/{}. Waiting {} ms...",
                            analysisId, retryCount, maxRetries, retryDelayMs);

                    try {
                        Thread.sleep(retryDelayMs);
                        retryDelayMs *= 2;
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        log.error("Retry interrupted", e);
                        return;
                    }
                } else {
                    log.info("Successfully retrieved analysis after {} retries", retryCount);
                }
            } catch (Exception e) {
                log.error("Error retrieving analysis with ID: {}", analysisId, e);
                retryCount++;
                try {
                    Thread.sleep(retryDelayMs);
                    retryDelayMs *= 2;
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
        }

        if (analysis == null) {
            log.error("Failed to retrieve analysis with ID: {} after {} retries. Aborting vulnerability check.",
                    analysisId, maxRetries);
            return;
        }

        try {
            if (analysis.getVulnerabilityCheckStatus() == DependencyAnalysis.VulnerabilityCheckStatus.NOT_STARTED) {
                analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.IN_PROGRESS);
                dependencyAnalysisRepository.save(analysis);
                log.info("Updated analysis status to IN_PROGRESS for ID: {}", analysisId);
            }

            List<Dependency> dependencies = dependencyRepository.findByAnalysisId(analysisId);

            if (dependencies.isEmpty()) {
                log.warn("No dependencies found for analysis ID: {}", analysisId);
                analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
                dependencyAnalysisRepository.save(analysis);
                return;
            }

            log.info("Processing {} dependencies in batches for analysis ID: {}, batch size: {}",
                    dependencies.size(), analysisId, batchSize);

            int total = dependencies.size();
            int processed = 0;

            for (int i = 0; i < total; i += batchSize) {
                int end = Math.min(i + batchSize, total);
                List<Dependency> batch = dependencies.subList(i, end);

                try {
                    List<DependencyCoordinates> coordinates = batch.stream()
                            .map(dep -> new DependencyCoordinates(
                                    dep.getGroupId(), dep.getArtifactId(), dep.getCurrentVersion()))
                            .toList();

                    Map<String, List<VulnerabilityResponse>> batchResults = checkVulnerabilitiesBatch(coordinates);

                    for (Dependency dependency : batch) {
                        String key = dependency.getGroupId() + ":" + dependency.getArtifactId() + ":" + dependency.getCurrentVersion();

                        List<VulnerabilityResponse> vulnerabilities = batchResults.getOrDefault(key, Collections.emptyList());

                        if (!vulnerabilities.isEmpty()) {
                            log.info("Found {} vulnerabilities for {}:{}:{}",
                                    vulnerabilities.size(), dependency.getGroupId(),
                                    dependency.getArtifactId(), dependency.getCurrentVersion());
                        }

                        updateDependencyWithVulnerabilities(dependency, vulnerabilities);
                    }

                    processed += batch.size();
                    log.info("Processed {}/{} dependencies for analysis ID: {}", processed, total, analysisId);

                } catch (Exception e) {
                    log.error("Error processing batch for analysis ID: {}", analysisId, e);
                }
            }

            analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
            dependencyAnalysisRepository.save(analysis);
            log.info("Completed vulnerability batch processing for analysis ID: {}", analysisId);

        } catch (Exception e) {
            log.error("Error during batch vulnerability processing for analysis ID: {}", analysisId, e);
            try {
                if (analysis != null) {
                    analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
                    dependencyAnalysisRepository.save(analysis);
                }
            } catch (Exception ex) {
                log.error("Failed to update analysis status after error", ex);
            }
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public DependencyAnalysis getAnalysisWithFreshTransaction(Long analysisId) {
        log.debug("Fetching analysis with ID: {} in a fresh transaction", analysisId);
        entityManager.flush();
        entityManager.clear();
        return dependencyAnalysisRepository.findById(analysisId).orElse(null);
    }

    private void updateDependencyWithVulnerabilities(
            Dependency dependency, List<VulnerabilityResponse> vulnerabilities) {
        try {
            boolean isVulnerable = !vulnerabilities.isEmpty();
            dependency.setIsVulnerable(isVulnerable);
            dependency.setVulnerableCount(vulnerabilities.size());

            if (isVulnerable) {
                dependency.setStatus("Vulnerable");
            }

            dependencyRepository.save(dependency);

            if (isVulnerable) {
                for (VulnerabilityResponse vulnResponse : vulnerabilities) {
                    Vulnerability vulnerability = Vulnerability.builder()
                            .dependency(dependency)
                            .name(vulnResponse.getName())
                            .description(vulnResponse.getDescription())
                            .severity(vulnResponse.getSeverity())
                            .affectedVersions(vulnResponse.getAffectedVersions())
                            .fixedInVersion(vulnResponse.getFixedInVersion())
                            .build();

                    vulnerabilityRepository.save(vulnerability);
                }

                log.info("Added {} vulnerabilities for {}:{}:{}",
                        vulnerabilities.size(), dependency.getGroupId(),
                        dependency.getArtifactId(), dependency.getCurrentVersion());
            }
        } catch (Exception e) {
            log.error("Error updating dependency vulnerabilities for {}:{}:{}",
                    dependency.getGroupId(), dependency.getArtifactId(),
                    dependency.getCurrentVersion(), e);
        }
    }

    @Getter
    @AllArgsConstructor
    private static class DependencyCoordinates {
        private final String groupId;
        private final String artifactId;
        private final String version;
    }
} 