{"ast":null,"code":"import { schemeCategory10 as e, schemeAccent as r, schemeDark2 as n, schemePaired as t, schemePastel1 as o, schemePastel2 as i, schemeSet1 as u, schemeSet2 as a, schemeSet3 as l, schemeTableau10 as c, schemeBrBG as s, schemePRGn as f, schemePiYG as p, schemePuOr as d, schemeRdBu as m, schemeRdGy as h, schemeRdYlBu as g, schemeRdYlGn as y, schemeSpectral as b, interpolateBrBG as v, interpolatePRGn as _, interpolatePiYG as w, interpolatePuOr as k, interpolateRdBu as j, interpolateRdGy as A, interpolateRdYlBu as O, interpolateRdYlGn as z, interpolateSpectral as E, schemeBlues as x, schemeGreens as I, schemeGreys as S, schemeOranges as q, schemePurples as C, schemeReds as G, schemeBuGn as R, schemeBuPu as V, schemeGnBu as P, schemeOrRd as T, schemePuBuGn as U, schemePuBu as D, schemePuRd as M, schemeRdPu as $, schemeYlGnBu as B, schemeYlGn as F, schemeYlOrBr as H, schemeYlOrRd as J, interpolateBlues as K, interpolateGreens as L, interpolateGreys as N, interpolateOranges as Q, interpolatePurples as W, interpolateReds as X, interpolateTurbo as Y, interpolateViridis as Z, interpolateInferno as ee, interpolateMagma as re, interpolatePlasma as ne, interpolateCividis as te, interpolateWarm as oe, interpolateCool as ie, interpolateCubehelixDefault as ue, interpolateBuGn as ae, interpolateBuPu as le, interpolateGnBu as ce, interpolateOrRd as se, interpolatePuBuGn as fe, interpolatePuBu as pe, interpolatePuRd as de, interpolateRdPu as me, interpolateYlGnBu as he, interpolateYlGn as ge, interpolateYlOrBr as ye, interpolateYlOrRd as be, interpolateRainbow as ve, interpolateSinebow as _e } from \"d3-scale-chromatic\";\nimport { useMemo as we } from \"react\";\nimport ke from \"lodash/get\";\nimport je from \"lodash/isPlainObject\";\nimport { rgb as Ae } from \"d3-color\";\nimport Oe from \"prop-types\";\nimport { scaleSequential as ze, scaleDiverging as Ee, scaleQuantize as xe, scaleLinear as Ie, scaleOrdinal as Se } from \"d3-scale\";\nfunction qe() {\n  return qe = Object.assign ? Object.assign.bind() : function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var n = arguments[r];\n      for (var t in n) Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);\n    }\n    return e;\n  }, qe.apply(this, arguments);\n}\nfunction Ce(e, r) {\n  (null == r || r > e.length) && (r = e.length);\n  for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];\n  return t;\n}\nfunction Ge(e, r) {\n  var n = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n) return (n = n.call(e)).next.bind(n);\n  if (Array.isArray(e) || (n = function (e, r) {\n    if (e) {\n      if (\"string\" == typeof e) return Ce(e, r);\n      var n = Object.prototype.toString.call(e).slice(8, -1);\n      return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(e) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ce(e, r) : void 0;\n    }\n  }(e)) || r && e && \"number\" == typeof e.length) {\n    n && (e = n);\n    var t = 0;\n    return function () {\n      return t >= e.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: e[t++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar Re = {\n    nivo: [\"#e8c1a0\", \"#f47560\", \"#f1e15b\", \"#e8a838\", \"#61cdbb\", \"#97e3d5\"],\n    category10: e,\n    accent: r,\n    dark2: n,\n    paired: t,\n    pastel1: o,\n    pastel2: i,\n    set1: u,\n    set2: a,\n    set3: l,\n    tableau10: c\n  },\n  Ve = Object.keys(Re),\n  Pe = {\n    brown_blueGreen: s,\n    purpleRed_green: f,\n    pink_yellowGreen: p,\n    purple_orange: d,\n    red_blue: m,\n    red_grey: h,\n    red_yellow_blue: g,\n    red_yellow_green: y,\n    spectral: b\n  },\n  Te = Object.keys(Pe),\n  Ue = {\n    brown_blueGreen: v,\n    purpleRed_green: _,\n    pink_yellowGreen: w,\n    purple_orange: k,\n    red_blue: j,\n    red_grey: A,\n    red_yellow_blue: O,\n    red_yellow_green: z,\n    spectral: E\n  },\n  De = {\n    blues: x,\n    greens: I,\n    greys: S,\n    oranges: q,\n    purples: C,\n    reds: G,\n    blue_green: R,\n    blue_purple: V,\n    green_blue: P,\n    orange_red: T,\n    purple_blue_green: U,\n    purple_blue: D,\n    purple_red: M,\n    red_purple: $,\n    yellow_green_blue: B,\n    yellow_green: F,\n    yellow_orange_brown: H,\n    yellow_orange_red: J\n  },\n  Me = Object.keys(De),\n  $e = {\n    blues: K,\n    greens: L,\n    greys: N,\n    oranges: Q,\n    purples: W,\n    reds: X,\n    turbo: Y,\n    viridis: Z,\n    inferno: ee,\n    magma: re,\n    plasma: ne,\n    cividis: te,\n    warm: oe,\n    cool: ie,\n    cubehelixDefault: ue,\n    blue_green: ae,\n    blue_purple: le,\n    green_blue: ce,\n    orange_red: se,\n    purple_blue_green: fe,\n    purple_blue: pe,\n    purple_red: de,\n    red_purple: me,\n    yellow_green_blue: he,\n    yellow_green: ge,\n    yellow_orange_brown: ye,\n    yellow_orange_red: be\n  },\n  Be = qe({}, Re, Pe, De),\n  Fe = Object.keys(Be),\n  He = function (e) {\n    return Ve.includes(e);\n  },\n  Je = function (e) {\n    return Te.includes(e);\n  },\n  Ke = function (e) {\n    return Me.includes(e);\n  },\n  Le = {\n    rainbow: ve,\n    sinebow: _e\n  },\n  Ne = qe({}, Ue, $e, Le),\n  Qe = Object.keys(Ne),\n  We = function (e, r) {\n    if (\"function\" == typeof e) return e;\n    if (je(e)) {\n      if (function (e) {\n        return void 0 !== e.theme;\n      }(e)) {\n        if (void 0 === r) throw new Error(\"Unable to use color from theme as no theme was provided\");\n        var n = ke(r, e.theme);\n        if (void 0 === n) throw new Error(\"Color from theme is undefined at path: '\" + e.theme + \"'\");\n        return function () {\n          return n;\n        };\n      }\n      if (function (e) {\n        return void 0 !== e.from;\n      }(e)) {\n        var t = function (r) {\n          return ke(r, e.from);\n        };\n        if (Array.isArray(e.modifiers)) {\n          for (var o, i = [], u = function () {\n              var e = o.value,\n                r = e[0],\n                n = e[1];\n              if (\"brighter\" === r) i.push(function (e) {\n                return e.brighter(n);\n              });else if (\"darker\" === r) i.push(function (e) {\n                return e.darker(n);\n              });else {\n                if (\"opacity\" !== r) throw new Error(\"Invalid color modifier: '\" + r + \"', must be one of: 'brighter', 'darker', 'opacity'\");\n                i.push(function (e) {\n                  return e.opacity = n, e;\n                });\n              }\n            }, a = Ge(e.modifiers); !(o = a()).done;) u();\n          return 0 === i.length ? t : function (e) {\n            return i.reduce(function (e, r) {\n              return r(e);\n            }, Ae(t(e))).toString();\n          };\n        }\n        return t;\n      }\n      throw new Error(\"Invalid color spec, you should either specify 'theme' or 'from' when using a config object\");\n    }\n    return function () {\n      return e;\n    };\n  },\n  Xe = function (e, r) {\n    return we(function () {\n      return We(e, r);\n    }, [e, r]);\n  },\n  Ye = Oe.oneOfType([Oe.string, Oe.func, Oe.shape({\n    theme: Oe.string.isRequired\n  }), Oe.shape({\n    from: Oe.string.isRequired,\n    modifiers: Oe.arrayOf(Oe.array)\n  })]),\n  Ze = {\n    scheme: \"turbo\"\n  },\n  er = function (e, r) {\n    var n = e.minValue,\n      t = e.maxValue,\n      o = void 0 !== n ? n : r.min,\n      i = void 0 !== t ? t : r.max,\n      u = ze().domain([o, i]).clamp(!0);\n    if (\"colors\" in e) u.range(e.colors);else if (\"interpolator\" in e) u.interpolator(e.interpolator);else {\n      var a,\n        l = null != (a = e.scheme) ? a : Ze.scheme;\n      u.interpolator(Ne[l]);\n    }\n    return u;\n  },\n  rr = function (e, r) {\n    return we(function () {\n      return er(e, r);\n    }, [e, r]);\n  },\n  nr = {\n    scheme: \"red_yellow_blue\",\n    divergeAt: .5\n  },\n  tr = function (e, r) {\n    var n,\n      t = e.minValue,\n      o = e.maxValue,\n      i = void 0 !== t ? t : r.min,\n      u = void 0 !== o ? o : r.max,\n      a = [i, i + (u - i) / 2, u],\n      l = .5 - (null != (n = e.divergeAt) ? n : nr.divergeAt),\n      c = Ee().domain(a).clamp(!0),\n      s = function (e) {\n        return String(e);\n      };\n    if (\"colors\" in e) s = Ee().domain(a.map(function (e) {\n      return e - l * (u - i);\n    })).range(e.colors).interpolator();else if (\"interpolator\" in e) s = e.interpolator;else {\n      var f,\n        p = null != (f = e.scheme) ? f : nr.scheme;\n      s = Ne[p];\n    }\n    return c.interpolator(function (e) {\n      return s(e + l);\n    });\n  },\n  or = function (e, r) {\n    return we(function () {\n      return tr(e, r);\n    }, [e, r]);\n  },\n  ir = {\n    scheme: \"turbo\",\n    steps: 7\n  },\n  ur = function (e, r) {\n    var n = xe().domain(e.domain || [r.min, r.max]).nice();\n    if (\"colors\" in e) n.range(e.colors);else {\n      var t = e.scheme || ir.scheme,\n        o = void 0 === e.steps ? ir.steps : e.steps,\n        i = Ne[t],\n        u = Array.from({\n          length: o\n        }).map(function (e, r) {\n          return i(r * (1 / (o - 1)));\n        });\n      n.range(u);\n    }\n    return n;\n  },\n  ar = function (e, r) {\n    return we(function () {\n      return ur(e, r);\n    }, [e, r]);\n  },\n  lr = function (e, r) {\n    if (function (e) {\n      return \"sequential\" === e.type;\n    }(e)) return er(e, r);\n    if (function (e) {\n      return \"diverging\" === e.type;\n    }(e)) return tr(e, r);\n    if (function (e) {\n      return \"quantize\" === e.type;\n    }(e)) return ur(e, r);\n    throw new Error(\"Invalid continuous color scale config\");\n  },\n  cr = function (e, r) {\n    return we(function () {\n      return lr(e, r);\n    }, [e, r]);\n  },\n  sr = function (e, r) {\n    void 0 === r && (r = 16);\n    var n = e.domain();\n    if (\"thresholds\" in e) {\n      var t = [],\n        o = Ie().domain(n).range([0, 1]);\n      return e.range().forEach(function (r, n) {\n        var i = e.invertExtent(r),\n          u = i[0],\n          a = i[1];\n        t.push({\n          key: n + \".0\",\n          offset: o(u),\n          stopColor: r\n        }), t.push({\n          key: n + \".1\",\n          offset: o(a),\n          stopColor: r\n        });\n      }), t;\n    }\n    var i = e.copy();\n    return 2 === n.length ? i.domain([0, 1]) : 3 === n.length && i.domain([0, .5, 1]), i.ticks(r).map(function (e) {\n      return {\n        key: \"\" + e,\n        offset: e,\n        stopColor: \"\" + i(e)\n      };\n    });\n  },\n  fr = function (e, r) {\n    if (\"function\" == typeof e) return e;\n    var n = \"function\" == typeof r ? r : function (e) {\n      return ke(e, r);\n    };\n    if (Array.isArray(e)) {\n      var t = Se(e),\n        o = function (e) {\n          return t(n(e));\n        };\n      return o.scale = t, o;\n    }\n    if (je(e)) {\n      if (function (e) {\n        return void 0 !== e.datum;\n      }(e)) return function (r) {\n        return ke(r, e.datum);\n      };\n      if (function (e) {\n        return void 0 !== e.scheme;\n      }(e)) {\n        if (He(e.scheme)) {\n          var i = Se(Be[e.scheme]),\n            u = function (e) {\n              return i(n(e));\n            };\n          return u.scale = i, u;\n        }\n        if (Je(e.scheme)) {\n          if (void 0 !== e.size && (e.size < 3 || e.size > 11)) throw new Error(\"Invalid size '\" + e.size + \"' for diverging color scheme '\" + e.scheme + \"', must be between 3~11\");\n          var a = Se(Be[e.scheme][e.size || 11]),\n            l = function (e) {\n              return a(n(e));\n            };\n          return l.scale = a, l;\n        }\n        if (Ke(e.scheme)) {\n          if (void 0 !== e.size && (e.size < 3 || e.size > 9)) throw new Error(\"Invalid size '\" + e.size + \"' for sequential color scheme '\" + e.scheme + \"', must be between 3~9\");\n          var c = Se(Be[e.scheme][e.size || 9]),\n            s = function (e) {\n              return c(n(e));\n            };\n          return s.scale = c, s;\n        }\n      }\n      throw new Error(\"Invalid colors, when using an object, you should either pass a 'datum' or a 'scheme' property\");\n    }\n    return function () {\n      return e;\n    };\n  },\n  pr = function (e, r) {\n    return we(function () {\n      return fr(e, r);\n    }, [e, r]);\n  };\nexport { Ve as categoricalColorSchemeIds, Re as categoricalColorSchemes, Qe as colorInterpolatorIds, Ne as colorInterpolators, Fe as colorSchemeIds, Be as colorSchemes, sr as computeContinuousColorScaleColorStops, Le as cyclicalColorInterpolators, Ue as divergingColorInterpolators, nr as divergingColorScaleDefaults, Te as divergingColorSchemeIds, Pe as divergingColorSchemes, lr as getContinuousColorScale, tr as getDivergingColorScale, We as getInheritedColorGenerator, fr as getOrdinalColorScale, ur as getQuantizeColorScale, er as getSequentialColorScale, Ye as inheritedColorPropType, He as isCategoricalColorScheme, Je as isDivergingColorScheme, Ke as isSequentialColorScheme, ir as quantizeColorScaleDefaults, $e as sequentialColorInterpolators, Ze as sequentialColorScaleDefaults, Me as sequentialColorSchemeIds, De as sequentialColorSchemes, cr as useContinuousColorScale, or as useDivergingColorScale, Xe as useInheritedColor, pr as useOrdinalColorScale, ar as useQuantizeColorScale, rr as useSequentialColorScale };\n//# sourceMappingURL=nivo-colors.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}