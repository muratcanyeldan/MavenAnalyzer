package com.muratcan.yeldan.mavenanalyzer.service.impl;

import com.muratcan.yeldan.mavenanalyzer.dto.AppSettingsResponse;
import com.muratcan.yeldan.mavenanalyzer.dto.VulnerabilityResponse;
import com.muratcan.yeldan.mavenanalyzer.dto.ossindex.OssIndexRequest;
import com.muratcan.yeldan.mavenanalyzer.dto.ossindex.OssIndexResponse;
import com.muratcan.yeldan.mavenanalyzer.dto.ossindex.OssIndexVulnerability;
import com.muratcan.yeldan.mavenanalyzer.entity.Dependency;
import com.muratcan.yeldan.mavenanalyzer.entity.DependencyAnalysis;
import com.muratcan.yeldan.mavenanalyzer.entity.Project;
import com.muratcan.yeldan.mavenanalyzer.entity.Vulnerability;
import com.muratcan.yeldan.mavenanalyzer.repository.DependencyAnalysisRepository;
import com.muratcan.yeldan.mavenanalyzer.repository.DependencyRepository;
import com.muratcan.yeldan.mavenanalyzer.repository.VulnerabilityRepository;
import com.muratcan.yeldan.mavenanalyzer.service.AppSettingsService;
import com.muratcan.yeldan.mavenanalyzer.service.VulnerabilityService;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Implementation of the VulnerabilityService interface that fetches real vulnerability data
 * from the OSS Index API.
 */
@Service
@Slf4j
public class VulnerabilityServiceImpl implements VulnerabilityService {

    private final RestTemplate restTemplate;
    private final DependencyRepository dependencyRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final DependencyAnalysisRepository dependencyAnalysisRepository;
    private final AppSettingsService appSettingsService;

    // Using ObjectProvider to lazily resolve the circular dependency
    private final ObjectProvider<VulnerabilityService> vulnerabilityServiceProvider;

    @Value("${vulnerability.ossindex.api.url.unauthorized:https://ossindex.sonatype.org/api/v3/component-report}")
    private String unauthorizedApiUrl;

    @Value("${vulnerability.ossindex.api.url.authorized:https://ossindex.sonatype.org/api/v3/authorized/component-report}")
    private String authorizedApiUrl;

    @Value("${vulnerability.ossindex.auth.enabled:false}")
    private boolean authEnabled;

    @Value("${vulnerability.ossindex.auth.username:}")
    private String ossIndexUsername;

    @Value("${vulnerability.ossindex.auth.token:}")
    private String ossIndexToken;

    @Value("${vulnerability.batch.size:20}")
    private int batchSize;

    @Value("${vulnerability.mock.enabled:true}")
    private boolean mockEnabled;

    @Getter
    @Value("${vulnerability.cache.enabled:true}")
    private boolean cacheEnabled;

    @PersistenceContext
    private EntityManager entityManager;

    public VulnerabilityServiceImpl(
            RestTemplate restTemplate,
            DependencyRepository dependencyRepository,
            VulnerabilityRepository vulnerabilityRepository,
            DependencyAnalysisRepository dependencyAnalysisRepository,
            AppSettingsService appSettingsService,
            ObjectProvider<VulnerabilityService> vulnerabilityServiceProvider) {
        this.restTemplate = restTemplate;
        this.dependencyRepository = dependencyRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.dependencyAnalysisRepository = dependencyAnalysisRepository;
        this.appSettingsService = appSettingsService;
        this.vulnerabilityServiceProvider = vulnerabilityServiceProvider;
    }

    // Helper method to get the proxied service
    private VulnerabilityService getProxiedSelf() {
        return vulnerabilityServiceProvider.getObject();
    }

    /**
     * Check for vulnerabilities in a specific Maven dependency
     *
     * @param groupId    The Maven group ID
     * @param artifactId The Maven artifact ID
     * @param version    The version of the dependency
     * @return List of vulnerabilities found
     */
    @Override
    @Cacheable(value = "vulnerabilities", key = "#groupId + ':' + #artifactId + ':' + #version",
            condition = "#root.target.cacheEnabled")
    public List<VulnerabilityResponse> checkVulnerabilities(String groupId, String artifactId, String version) {
        // If mock mode is enabled, return mock data immediately
        if (mockEnabled) {
            log.info("Mock mode enabled. Generating mock vulnerabilities for {}:{}:{}", groupId, artifactId, version);
            return generateMockVulnerabilities(groupId, artifactId, version);
        }

        try {
            log.info("Checking vulnerabilities for {}:{}:{}", groupId, artifactId, version);

            // Build the package coordinates
            String packageCoordinates = String.format("pkg:maven/%s/%s@%s", groupId, artifactId, version);

            // For single dependency check, we'll still use the batch method
            List<DependencyCoordinates> dependencies = Collections.singletonList(
                    new DependencyCoordinates(groupId, artifactId, version)
            );

            // Make the batch API call
            Map<String, List<VulnerabilityResponse>> batchResults = checkVulnerabilitiesBatch(dependencies);

            // Extract results for this specific dependency
            String key = groupId + ":" + artifactId + ":" + version;
            List<VulnerabilityResponse> vulnerabilities = batchResults.getOrDefault(key, new ArrayList<>());

            log.debug("Retrieved {} vulnerabilities for {}:{}:{} from OSS Index API",
                    vulnerabilities.size(), groupId, artifactId, version);

            // If no vulnerabilities found and we're in mock mode, return mock data
            if (vulnerabilities.isEmpty() && mockEnabled) {
                log.info("No vulnerabilities found from API, but mock mode is enabled. Generating mock data for {}:{}:{}",
                        groupId, artifactId, version);
                return generateMockVulnerabilities(groupId, artifactId, version);
            }

            return vulnerabilities;
        } catch (Exception e) {
            log.error("Error checking vulnerabilities for {}:{}:{}", groupId, artifactId, version, e);
            // Fall back to mock data in case of an error if mock mode is enabled
            if (mockEnabled) {
                log.info("Error occurred, falling back to mock data for {}:{}:{}", groupId, artifactId, version);
                return generateMockVulnerabilities(groupId, artifactId, version);
            }
            return new ArrayList<>();
        }
    }

    /**
     * Asynchronously check for vulnerabilities in a specific Maven dependency
     *
     * @param groupId    The Maven group ID
     * @param artifactId The Maven artifact ID
     * @param version    The version of the dependency
     * @param analysisId The ID of the analysis this check is part of
     * @return A CompletableFuture that will be completed with the list of vulnerabilities found
     */
    @Override
    @Async("taskExecutor")
    @Transactional
    public CompletableFuture<List<VulnerabilityResponse>> checkVulnerabilitiesAsync(
            String groupId, String artifactId, String version, Long analysisId) {
        long startTime = System.currentTimeMillis();
        log.info("Asynchronously checking vulnerabilities for {}:{}:{} (Analysis ID: {})",
                groupId, artifactId, version, analysisId);

        try {
            // Get vulnerabilities synchronously (the @Async annotation makes the entire method asynchronous)
            // We need to use the proxied self here to make sure cache and transaction aspects are applied
            List<VulnerabilityResponse> vulnerabilities = getProxiedSelf().checkVulnerabilities(groupId, artifactId, version);
            long apiCheckTime = System.currentTimeMillis();

            log.info("Found {} vulnerabilities for {}:{}:{} in {} ms",
                    vulnerabilities.size(), groupId, artifactId, version, (apiCheckTime - startTime));

            // Update the dependency and add vulnerabilities - using proxied self again
            getProxiedSelf().updateDependencyVulnerabilities(groupId, artifactId, version, analysisId, vulnerabilities);
            long updateTime = System.currentTimeMillis();
            log.info("Updated dependency vulnerabilities for {}:{}:{} in {} ms",
                    groupId, artifactId, version, (updateTime - apiCheckTime));

            // Check if all dependencies have been processed and update analysis status if needed
            getProxiedSelf().checkAndUpdateAnalysisStatus(analysisId);
            long totalTime = System.currentTimeMillis() - startTime;

            log.info("Completed vulnerability check for {}:{}:{} (Analysis ID: {}) in {} ms",
                    groupId, artifactId, version, analysisId, totalTime);

            return CompletableFuture.completedFuture(vulnerabilities);
        } catch (Exception e) {
            log.error("Error in async vulnerability check for {}:{}:{}", groupId, artifactId, version, e);
            // Make sure to update the analysis status even in case of errors
            getProxiedSelf().checkAndUpdateAnalysisStatus(analysisId);
            return CompletableFuture.completedFuture(new ArrayList<>());
        }
    }

    /**
     * Update a dependency with vulnerability information and add vulnerabilities to the database
     */
    @Override
    @Transactional
    public void updateDependencyVulnerabilities(
            String groupId, String artifactId, String version, Long analysisId,
            List<VulnerabilityResponse> vulnerabilities) {

        try {
            // Find the dependency in the database
            Dependency dependency = dependencyRepository.findByAnalysisIdAndGroupIdAndArtifactIdAndCurrentVersion(
                            analysisId, groupId, artifactId, version)
                    .orElse(null);

            if (dependency == null) {
                log.warn("Dependency {}:{}:{} not found for analysis ID: {}",
                        groupId, artifactId, version, analysisId);
                return;
            }

            // Update dependency vulnerability information
            boolean isVulnerable = !vulnerabilities.isEmpty();
            dependency.setIsVulnerable(isVulnerable);
            dependency.setVulnerableCount(vulnerabilities.size());

            dependencyRepository.save(dependency);

            // Add vulnerabilities to the database
            if (isVulnerable) {
                for (VulnerabilityResponse vulnResponse : vulnerabilities) {
                    Vulnerability vulnerability = Vulnerability.builder()
                            .dependency(dependency)
                            .name(vulnResponse.getName())
                            .description(vulnResponse.getDescription())
                            .severity(vulnResponse.getSeverity())
                            .affectedVersions(vulnResponse.getAffectedVersions())
                            .fixedInVersion(vulnResponse.getFixedInVersion())
                            .build();

                    vulnerabilityRepository.save(vulnerability);
                }

                log.info("Added {} vulnerabilities for {}:{}:{}",
                        vulnerabilities.size(), groupId, artifactId, version);
            }
        } catch (Exception e) {
            log.error("Error updating dependency vulnerabilities for {}:{}:{}",
                    groupId, artifactId, version, e);
        }
    }

    /**
     * Check if all dependencies for an analysis have been processed for vulnerabilities
     * and update the analysis status if needed
     */
    @Override
    @Transactional
    public void checkAndUpdateAnalysisStatus(Long analysisId) {
        try {
            DependencyAnalysis analysis = dependencyAnalysisRepository.findById(analysisId)
                    .orElse(null);

            if (analysis == null) {
                log.warn("Analysis not found with ID: {}", analysisId);
                return;
            }

            // Only proceed if the analysis is still in progress
            if (analysis.getVulnerabilityCheckStatus() == DependencyAnalysis.VulnerabilityCheckStatus.IN_PROGRESS) {
                // Count dependencies with vulnerability status set (either vulnerable or not)
                long processedCount = dependencyRepository.countByAnalysisIdAndVulnerableStatusSet(analysisId);
                int totalDependencies = analysis.getTotalDependencies();

                log.info("Vulnerability check status: Processed {}/{} dependencies for analysis ID: {}",
                        processedCount, totalDependencies, analysisId);

                // If all dependencies have been processed, update the analysis status
                if (processedCount >= totalDependencies) {
                    analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
                    dependencyAnalysisRepository.save(analysis);
                    log.info("All dependencies processed for vulnerabilities. Analysis ID: {} marked as COMPLETED", analysisId);

                    // Send completion notification if enabled
                    if (analysis.isNotifyOnCompletion()) {
                        sendCompletionNotification(analysis);
                    }
                } else {
                    log.debug("Vulnerability check still in progress. Processed {}/{} dependencies for analysis ID: {}",
                            processedCount, totalDependencies, analysisId);
                }
            } else {
                log.debug("Analysis ID: {} is not in IN_PROGRESS state (current state: {})",
                        analysisId, analysis.getVulnerabilityCheckStatus());
            }
        } catch (Exception e) {
            log.error("Error checking and updating analysis status for ID: {}", analysisId, e);
            // Try to recover from error by checking if we need to mark as completed anyway
            try {
                DependencyAnalysis analysis = dependencyAnalysisRepository.findById(analysisId).orElse(null);
                if (analysis != null && analysis.getVulnerabilityCheckStatus() == DependencyAnalysis.VulnerabilityCheckStatus.IN_PROGRESS) {
                    // Force update to COMPLETED if we had an error to avoid stuck status
                    analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
                    dependencyAnalysisRepository.save(analysis);
                    log.info("Force updated analysis ID: {} to COMPLETED after error", analysisId);
                }
            } catch (Exception ex) {
                log.error("Failed to recover analysis status for ID: {}", analysisId, ex);
            }
        }
    }

    /**
     * Sends a notification that the analysis is complete
     */
    private void sendCompletionNotification(DependencyAnalysis analysis) {
        try {
            // Check if global notifications are enabled in app settings
            AppSettingsResponse settings = appSettingsService.getSettings();
            if (!Boolean.TRUE.equals(settings.getShowNotifications())) {
                log.debug("Notifications are disabled globally, skipping completion notification for analysis ID: {}", analysis.getId());
                return;
            }

            log.info("Sending analysis completion notification for analysis ID: {}", analysis.getId());

            Project project = analysis.getProject();
            String projectName = project != null ? project.getName() : "Standalone Analysis";

            // Count vulnerable dependencies
            long vulnerableCount = analysis.getDependencies().stream()
                    .filter(d -> d.getIsVulnerable() != null && d.getIsVulnerable())
                    .count();

            // Create notification message
            String notificationMessage = String.format(
                    "Analysis completed for %s. Found %d dependencies (%d outdated, %d vulnerable).",
                    projectName,
                    analysis.getTotalDependencies(),
                    analysis.getOutdatedDependencies(),
                    vulnerableCount
            );

            // In a real implementation, this would send a system notification, email, or push notification
            // For demo purposes, we'll just log it
            log.info("NOTIFICATION: {}", notificationMessage);

            // If you had a notification service, you would inject and call it here:
            // notificationService.sendNotification(analysis.getProject(), "Analysis Complete", notificationMessage);
        } catch (Exception e) {
            log.error("Error sending completion notification for analysis ID: {}", analysis.getId(), e);
        }
    }

    /**
     * Check if a dependency has any vulnerabilities
     *
     * @param groupId    The Maven group ID
     * @param artifactId The Maven artifact ID
     * @param version    The version of the dependency
     * @return true if vulnerabilities were found, false otherwise
     */
    @Override
    @Cacheable(value = "vulnerabilityCounts", key = "'has:' + #groupId + ':' + #artifactId + ':' + #version",
            condition = "#root.target.cacheEnabled")
    public boolean hasVulnerabilities(String groupId, String artifactId, String version) {
        log.debug("Checking if {}:{}:{} has vulnerabilities (Cache miss or disabled)", groupId, artifactId, version);

        if (mockEnabled) {
            // For demo purposes, we'll just return a random boolean
            return Math.random() > 0.7; // 30% chance of having a vulnerability
        }

        try {
            // Use the batch method with a singleton list to avoid duplicating API calls
            List<DependencyCoordinates> dependencies = Collections.singletonList(
                    new DependencyCoordinates(groupId, artifactId, version)
            );

            Map<String, List<VulnerabilityResponse>> batchResults = checkVulnerabilitiesBatch(dependencies);

            String key = groupId + ":" + artifactId + ":" + version;
            List<VulnerabilityResponse> vulnerabilities = batchResults.getOrDefault(key, new ArrayList<>());

            return !vulnerabilities.isEmpty();
        } catch (Exception e) {
            log.error("Error checking if dependency has vulnerabilities", e);
            return false;
        }
    }

    /**
     * Get the count of vulnerabilities for a dependency
     *
     * @param groupId    The Maven group ID
     * @param artifactId The Maven artifact ID
     * @param version    The version of the dependency
     * @return The number of vulnerabilities found
     */
    @Override
    @Cacheable(value = "vulnerabilityCounts", key = "'count:' + #groupId + ':' + #artifactId + ':' + #version",
            condition = "#root.target.cacheEnabled")
    public int getVulnerabilityCount(String groupId, String artifactId, String version) {
        log.debug("Getting vulnerability count for {}:{}:{} (Cache miss or disabled)", groupId, artifactId, version);

        if (mockEnabled) {
            // For demo purposes, return a random count
            if (Math.random() > 0.7) {  // 30% chance of having vulnerabilities
                return (int) (Math.random() * 3) + 1;  // 1-3 vulnerabilities
            }
            return 0;
        }

        try {
            // Use the batch method with a singleton list to avoid duplicating API calls
            List<DependencyCoordinates> dependencies = Collections.singletonList(
                    new DependencyCoordinates(groupId, artifactId, version)
            );

            Map<String, List<VulnerabilityResponse>> batchResults = checkVulnerabilitiesBatch(dependencies);

            String key = groupId + ":" + artifactId + ":" + version;
            List<VulnerabilityResponse> vulnerabilities = batchResults.getOrDefault(key, new ArrayList<>());

            return vulnerabilities.size();
        } catch (Exception e) {
            log.error("Error getting vulnerability count", e);
            return 0;
        }
    }

    /**
     * Generate mock vulnerability data for testing and demo purposes
     */
    private List<VulnerabilityResponse> generateMockVulnerabilities(String groupId, String artifactId, String version) {
        try {
            // Simulate network delay
            Thread.sleep(300);

            // Known vulnerable libraries for more realistic demo data
            if (artifactId.contains("log4j") && version.startsWith("2")) {
                List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();

                // Add Log4Shell vulnerability if applicable
                if (version.matches("2\\.(0|1|2|3|4|5|6|7|8|9|10|11|12|13|14).*")) {
                    vulnerabilities.add(VulnerabilityResponse.builder()
                            .name("CVE-2021-44228")
                            .description("Log4j2 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. This allows an unauthenticated attacker to execute arbitrary code.")
                            .severity("CRITICAL")
                            .affectedVersions("2.0-beta9 to 2.14.1")
                            .fixedInVersion("2.15.0")
                            .build());
                }

                if (version.matches("2\\.(0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15).*")) {
                    vulnerabilities.add(VulnerabilityResponse.builder()
                            .name("CVE-2021-45046")
                            .description("The fix for CVE-2021-44228 was incomplete in certain non-default configurations.")
                            .severity("HIGH")
                            .affectedVersions("2.0-beta9 to 2.15.0")
                            .fixedInVersion("2.16.0")
                            .build());
                }

                return vulnerabilities;
            }

            // Add Spring Core RCE vulnerability (Spring4Shell)
            if (artifactId.contains("spring-core") && version.matches("5\\.(0|1|2|3\\.[0-8]).*")) {
                List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();
                vulnerabilities.add(VulnerabilityResponse.builder()
                        .name("CVE-2022-22965")
                        .description("Spring Framework RCE via Data Binding on JDK 9+")
                        .severity("CRITICAL")
                        .affectedVersions("5.3.0 to 5.3.17, 5.2.0 to 5.2.19, and older")
                        .fixedInVersion("5.3.18+ and 5.2.20+")
                        .build());
                return vulnerabilities;
            }

            // For commons-text (text4shell)
            if (artifactId.contains("commons-text") && version.matches("1\\.[0-9]\\.[0-9]")) {
                List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();
                vulnerabilities.add(VulnerabilityResponse.builder()
                        .name("CVE-2022-42889")
                        .description("Apache Commons Text's default string interpolation can lead to RCE in applications using defaults.")
                        .severity("HIGH")
                        .affectedVersions("1.5.0 to 1.9.0")
                        .fixedInVersion("1.10.0")
                        .build());
                return vulnerabilities;
            }

            // Random vulnerabilities for other dependencies to demonstrate the feature
            if (Math.random() > 0.75) {  // 25% chance of having a vulnerability
                List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();

                // Add a relevant-sounding vulnerability for the dependency
                vulnerabilities.add(VulnerabilityResponse.builder()
                        .name("CVE-" + (2021 + (int) (Math.random() * 2)) + "-" + (10000 + (int) (Math.random() * 9999)))
                        .description("Security vulnerability in " + artifactId + " allows attackers to " +
                                getRandomVulnerabilityImpact() + " through " + getRandomVulnerabilityVector())
                        .severity(getRandomSeverity())
                        .affectedVersions("<" + version)
                        .fixedInVersion(getIncrementedVersion(version))
                        .build());

                if (Math.random() > 0.7) {  // 30% chance of having multiple vulnerabilities
                    vulnerabilities.add(VulnerabilityResponse.builder()
                            .name("CVE-" + (2020 + (int) (Math.random() * 3)) + "-" + (10000 + (int) (Math.random() * 9999)))
                            .description("Another security issue found in " + artifactId + " that could allow " +
                                    getRandomVulnerabilityImpact())
                            .severity(getRandomSeverity())
                            .affectedVersions("<" + version)
                            .fixedInVersion(getIncrementedVersion(version))
                            .build());
                }

                return vulnerabilities;
            }

            return new ArrayList<>();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Thread interrupted", e);
            return new ArrayList<>();
        }
    }

    /**
     * Generate a random vulnerability impact description
     */
    private String getRandomVulnerabilityImpact() {
        String[] impacts = {
                "execute arbitrary code",
                "bypass authentication",
                "access sensitive information",
                "cause a denial of service",
                "elevate privileges",
                "modify data",
                "bypass security controls",
                "inject malicious code",
                "perform remote code execution",
                "read restricted files"
        };
        return impacts[(int) (Math.random() * impacts.length)];
    }

    /**
     * Generate a random vulnerability vector description
     */
    private String getRandomVulnerabilityVector() {
        String[] vectors = {
                "improper input validation",
                "insufficient access control",
                "insecure deserialization",
                "XML external entity processing",
                "server-side request forgery",
                "cross-site scripting",
                "SQL injection",
                "path traversal",
                "buffer overflow",
                "race condition"
        };
        return vectors[(int) (Math.random() * vectors.length)];
    }

    /**
     * Get an incremented version for mock "fixed in" versions
     */
    private String getIncrementedVersion(String version) {
        try {
            // Simple version incrementing for x.y.z format
            String[] parts = version.split("\\.");
            if (parts.length >= 3) {
                int patch = Integer.parseInt(parts[2]) + 1;
                return parts[0] + "." + parts[1] + "." + patch;
            } else if (parts.length == 2) {
                return parts[0] + "." + parts[1] + ".1";
            } else {
                return version + ".1";
            }
        } catch (Exception e) {
            // If parsing fails, just append .1
            return version + ".1";
        }
    }

    /**
     * Get a random severity level for mock vulnerabilities
     */
    private String getRandomSeverity() {
        String[] severities = {"LOW", "MEDIUM", "HIGH", "CRITICAL"};
        return severities[(int) (Math.random() * severities.length)];
    }

    /**
     * Convert a CVSS score to a severity string
     *
     * @param cvssScore The CVSS score (0.0-10.0)
     * @return The severity string (LOW, MEDIUM, HIGH, CRITICAL)
     */
    private String getSeverityFromCvssScore(Float cvssScore) {
        if (cvssScore == null) {
            return "UNKNOWN";
        }

        if (cvssScore >= 9.0) {
            return "CRITICAL";
        } else if (cvssScore >= 7.0) {
            return "HIGH";
        } else if (cvssScore >= 4.0) {
            return "MEDIUM";
        } else {
            return "LOW";
        }
    }

    /**
     * Manually clear the cache for a specific dependency
     *
     * @param groupId    The Maven group ID
     * @param artifactId The Maven artifact ID
     * @param version    The version of the dependency
     */
    @Override
    @CacheEvict(value = {"vulnerabilities", "vulnerabilityCounts"},
            key = "#groupId + ':' + #artifactId + ':' + #version")
    public void clearVulnerabilityCache(String groupId, String artifactId, String version) {
        log.info("Cleared vulnerability cache for {}:{}:{}", groupId, artifactId, version);
    }

    /**
     * Manually clear all vulnerability caches
     */
    @Override
    @CacheEvict(value = {"vulnerabilities", "vulnerabilityCounts"}, allEntries = true)
    public void clearAllVulnerabilityCaches() {
        log.info("Cleared all vulnerability caches");
    }

    /**
     * Helper method to get the OSS Index API URL based on auth settings
     *
     * @return the appropriate API URL
     */
    private String getApiUrl() {
        return authEnabled ? authorizedApiUrl : unauthorizedApiUrl;
    }

    /**
     * Prepare headers for OSS Index API calls, including authentication if enabled
     *
     * @return HttpHeaders with appropriate content type and auth
     */
    private HttpHeaders prepareHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        // Add Basic Authentication if enabled
        if (authEnabled && ossIndexUsername != null && !ossIndexUsername.isEmpty()
                && ossIndexToken != null && !ossIndexToken.isEmpty()) {

            String auth = ossIndexUsername + ":" + ossIndexToken;
            byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes(StandardCharsets.UTF_8));
            String authHeader = "Basic " + new String(encodedAuth);
            headers.set("Authorization", authHeader);

            log.debug("Added authentication headers for OSS Index API");
        }

        return headers;
    }

    /**
     * Check vulnerabilities for multiple dependencies in a single batch request
     *
     * @param dependencies List of dependencies with groupId, artifactId, and version
     * @return Map of coordinates to vulnerability lists
     */
    private Map<String, List<VulnerabilityResponse>> checkVulnerabilitiesBatch(
            List<DependencyCoordinates> dependencies) {

        if (dependencies.isEmpty()) {
            return Collections.emptyMap();
        }

        // If mock mode is enabled, return mock data for all dependencies
        if (mockEnabled) {
            log.info("Mock mode enabled. Generating mock vulnerabilities for {} dependencies", dependencies.size());
            Map<String, List<VulnerabilityResponse>> result = new HashMap<>();

            for (DependencyCoordinates dep : dependencies) {
                String key = dep.getGroupId() + ":" + dep.getArtifactId() + ":" + dep.getVersion();
                result.put(key, generateMockVulnerabilities(dep.getGroupId(), dep.getArtifactId(), dep.getVersion()));
            }

            return result;
        }

        try {
            log.info("Checking vulnerabilities in batch for {} dependencies", dependencies.size());

            // Build package coordinates for all dependencies
            List<String> coordinates = dependencies.stream()
                    .map(dep -> String.format("pkg:maven/%s/%s@%s",
                            dep.getGroupId(), dep.getArtifactId(), dep.getVersion()))
                    .collect(Collectors.toList());

            // Create the request body
            OssIndexRequest request = OssIndexRequest.builder()
                    .coordinates(coordinates)
                    .build();

            // Prepare headers with auth if needed
            HttpHeaders headers = prepareHeaders();

            // Create the HTTP entity
            HttpEntity<OssIndexRequest> entity = new HttpEntity<>(request, headers);

            // Make the API call to the appropriate URL
            ResponseEntity<OssIndexResponse[]> response = restTemplate.postForEntity(
                    getApiUrl(),
                    entity,
                    OssIndexResponse[].class
            );

            // Process the response
            Map<String, List<VulnerabilityResponse>> result = new HashMap<>();
            if (response.getBody() != null) {
                // Initialize with empty lists for all dependencies to ensure we have entries even for those without vulnerabilities
                for (DependencyCoordinates dep : dependencies) {
                    String key = dep.getGroupId() + ":" + dep.getArtifactId() + ":" + dep.getVersion();
                    result.put(key, new ArrayList<>());
                }

                // Process each response and map to the correct dependency
                for (OssIndexResponse ossResponse : response.getBody()) {
                    // Extract the coordinates from the response
                    // Format: pkg:maven/groupId/artifactId@version or pkg:maven/groupId/artifactId@version (from parent)
                    String coord = ossResponse.getCoordinates();

                    // Log the received coordinates for debugging
                    log.debug("Processing OssIndexResponse with coordinates: {}", coord);

                    // Clean up the coordinates by removing any parenthetical notes like "(from parent)"
                    String cleanCoord = coord.replaceAll("\\s+\\(.*\\)$", "");

                    String[] parts = cleanCoord.replace("pkg:maven/", "").split("@");
                    if (parts.length != 2) {
                        log.warn("Invalid coordinate format: {}", coord);
                        continue;
                    }

                    String groupArtifact = parts[0];
                    String version = parts[1];

                    // Further split groupId/artifactId
                    String[] groupArtParts = groupArtifact.split("/");
                    if (groupArtParts.length != 2) {
                        log.warn("Invalid groupId/artifactId format: {}", groupArtifact);
                        continue;
                    }

                    String groupId = groupArtParts[0];
                    String artifactId = groupArtParts[1];
                    String key = groupId + ":" + artifactId + ":" + version;

                    List<VulnerabilityResponse> vulnerabilities = new ArrayList<>();

                    if (ossResponse.getVulnerabilities() != null && !ossResponse.getVulnerabilities().isEmpty()) {
                        // Map the OSS Index vulnerabilities to our internal model
                        for (OssIndexVulnerability ossVuln : ossResponse.getVulnerabilities()) {
                            vulnerabilities.add(VulnerabilityResponse.builder()
                                    .name(ossVuln.getCve() != null ? ossVuln.getCve() : ossVuln.getId())
                                    .description(ossVuln.getDescription())
                                    .severity(getSeverityFromCvssScore(ossVuln.getCvssScore()))
                                    .affectedVersions(ossVuln.getVersionRanges())
                                    .fixedInVersion("Not specified") // OSS Index doesn't provide this directly
                                    .build());
                        }

                        // Log that we found vulnerabilities for this dependency
                        log.info("Found {} vulnerabilities for {}:{}:{} from OssIndex API",
                                vulnerabilities.size(), groupId, artifactId, version);
                    }

                    // Important: Merge any existing vulnerabilities rather than overwriting
                    List<VulnerabilityResponse> existingVulns = result.get(key);
                    if (existingVulns != null) {
                        existingVulns.addAll(vulnerabilities);
                        log.debug("Merged {} vulnerabilities into existing list for {}:{}:{}",
                                vulnerabilities.size(), groupId, artifactId, version);
                    } else {
                        result.put(key, vulnerabilities);
                    }

                    log.debug("Retrieved {} vulnerabilities for {}:{}:{} from OSS Index API",
                            vulnerabilities.size(), groupId, artifactId, version);
                }

                // For any dependency with empty vulnerability list and mock mode enabled, generate mock data
                if (mockEnabled) {
                    for (DependencyCoordinates dep : dependencies) {
                        String key = dep.getGroupId() + ":" + dep.getArtifactId() + ":" + dep.getVersion();
                        if (result.get(key).isEmpty()) {
                            log.info("No vulnerabilities found from API, but mock mode is enabled. Generating mock data for {}:{}:{}",
                                    dep.getGroupId(), dep.getArtifactId(), dep.getVersion());
                            result.put(key, generateMockVulnerabilities(dep.getGroupId(), dep.getArtifactId(), dep.getVersion()));
                        }
                    }
                }
            }

            return result;
        } catch (Exception e) {
            log.error("Error checking vulnerabilities in batch for {} dependencies", dependencies.size(), e);

            // Fall back to mock data if enabled
            if (mockEnabled) {
                Map<String, List<VulnerabilityResponse>> result = new HashMap<>();
                for (DependencyCoordinates dep : dependencies) {
                    String key = dep.getGroupId() + ":" + dep.getArtifactId() + ":" + dep.getVersion();
                    result.put(key, generateMockVulnerabilities(dep.getGroupId(), dep.getArtifactId(), dep.getVersion()));
                }
                return result;
            }

            // Otherwise return empty lists for all dependencies
            Map<String, List<VulnerabilityResponse>> result = new HashMap<>();
            for (DependencyCoordinates dep : dependencies) {
                String key = dep.getGroupId() + ":" + dep.getArtifactId() + ":" + dep.getVersion();
                result.put(key, new ArrayList<>());
            }
            return result;
        }
    }

    /**
     * Process all dependencies for an analysis in batches and check for vulnerabilities
     * This is more efficient than checking each dependency individually
     *
     * @param analysisId The ID of the analysis to process
     */
    @Override
    @Async("taskExecutor")
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void processDependenciesInBatches(Long analysisId) {
        log.info("Starting batch processing of vulnerabilities for analysis ID: {}", analysisId);

        // Enhanced retry logic with exponential backoff and better logging
        DependencyAnalysis analysis = null;
        int maxRetries = 5;
        int retryCount = 0;
        int retryDelayMs = 2000; // Increase initial delay to give transaction more time to commit
        boolean transactionBoundaryIssue = true;

        while (analysis == null && retryCount < maxRetries) {
            try {
                // Use a new transaction to ensure we're not using cached data
                analysis = getProxiedSelf().getAnalysisWithFreshTransaction(analysisId);

                if (analysis == null) {
                    retryCount++;
                    log.info("Transaction boundary issue: Analysis ID: {} not found yet. Retry attempt {}/{}. Waiting {} ms...",
                            analysisId, retryCount, maxRetries, retryDelayMs);

                    try {
                        // Wait before retrying
                        Thread.sleep(retryDelayMs);
                        // Exponential backoff - increase wait time for next retry
                        retryDelayMs *= 2;
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        log.error("Retry interrupted", e);
                        return;
                    }
                } else {
                    transactionBoundaryIssue = false;
                    log.info("Successfully retrieved analysis after {} retries", retryCount);
                }
            } catch (Exception e) {
                log.error("Error retrieving analysis with ID: {}", analysisId, e);
                retryCount++;
                try {
                    Thread.sleep(retryDelayMs);
                    retryDelayMs *= 2;
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
        }

        // If we exhausted all retries and still can't find the analysis
        if (analysis == null) {
            log.error("Failed to retrieve analysis with ID: {} after {} retries. Aborting vulnerability check.",
                    analysisId, maxRetries);
            return;
        }

        try {
            // Check if this analysis is in a valid state for processing
            if (analysis.getVulnerabilityCheckStatus() == DependencyAnalysis.VulnerabilityCheckStatus.NOT_STARTED) {
                // Update status to IN_PROGRESS
                analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.IN_PROGRESS);
                dependencyAnalysisRepository.save(analysis);
                log.info("Updated analysis status to IN_PROGRESS for ID: {}", analysisId);
            }

            // Get all dependencies for this analysis
            List<Dependency> dependencies = dependencyRepository.findByAnalysisId(analysisId);

            if (dependencies.isEmpty()) {
                log.warn("No dependencies found for analysis ID: {}", analysisId);
                analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
                dependencyAnalysisRepository.save(analysis);
                return;
            }

            log.info("Processing {} dependencies in batches for analysis ID: {}, batch size: {}",
                    dependencies.size(), analysisId, batchSize);

            // Process dependencies in batches
            int total = dependencies.size();
            int processed = 0;

            for (int i = 0; i < total; i += batchSize) {
                int end = Math.min(i + batchSize, total);
                List<Dependency> batch = dependencies.subList(i, end);

                try {
                    // Create a list of DependencyCoordinates for batch processing
                    List<DependencyCoordinates> coordinates = batch.stream()
                            .map(dep -> new DependencyCoordinates(
                                    dep.getGroupId(), dep.getArtifactId(), dep.getCurrentVersion()))
                            .collect(Collectors.toList());

                    // Process the batch
                    Map<String, List<VulnerabilityResponse>> batchResults = checkVulnerabilitiesBatch(coordinates);

                    // Update each dependency with its vulnerabilities
                    for (Dependency dependency : batch) {
                        String key = dependency.getGroupId() + ":" + dependency.getArtifactId() + ":" + dependency.getCurrentVersion();

                        // Use the simple key format instead of the OSS Index coordinate format
                        List<VulnerabilityResponse> vulnerabilities = batchResults.getOrDefault(key, Collections.emptyList());

                        // Log what we're updating for troubleshooting
                        if (!vulnerabilities.isEmpty()) {
                            log.info("Found {} vulnerabilities for {}:{}:{}",
                                    vulnerabilities.size(), dependency.getGroupId(),
                                    dependency.getArtifactId(), dependency.getCurrentVersion());
                        }

                        updateDependencyWithVulnerabilities(dependency, vulnerabilities);
                    }

                    processed += batch.size();
                    log.info("Processed {}/{} dependencies for analysis ID: {}", processed, total, analysisId);

                } catch (Exception e) {
                    log.error("Error processing batch for analysis ID: {}", analysisId, e);
                }
            }

            // Update analysis status to COMPLETED
            analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
            dependencyAnalysisRepository.save(analysis);
            log.info("Completed vulnerability batch processing for analysis ID: {}", analysisId);

        } catch (Exception e) {
            log.error("Error during batch vulnerability processing for analysis ID: {}", analysisId, e);
            try {
                // Try to update status to COMPLETED even if there was an error
                if (analysis != null) {
                    analysis.setVulnerabilityCheckStatus(DependencyAnalysis.VulnerabilityCheckStatus.COMPLETED);
                    dependencyAnalysisRepository.save(analysis);
                }
            } catch (Exception ex) {
                log.error("Failed to update analysis status after error", ex);
            }
        }
    }

    /**
     * Helper method to get analysis with a fresh transaction
     * This ensures we're not using cached data from a previous transaction
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public DependencyAnalysis getAnalysisWithFreshTransaction(Long analysisId) {
        log.debug("Fetching analysis with ID: {} in a fresh transaction", analysisId);
        // Clear any cached entities to ensure we get the latest from the database
        entityManager.flush();
        entityManager.clear();
        return dependencyAnalysisRepository.findById(analysisId).orElse(null);
    }

    /**
     * Helper method to update a dependency with vulnerability information
     */
    private void updateDependencyWithVulnerabilities(
            Dependency dependency, List<VulnerabilityResponse> vulnerabilities) {
        try {
            // Update vulnerability information
            boolean isVulnerable = !vulnerabilities.isEmpty();
            dependency.setIsVulnerable(isVulnerable);
            dependency.setVulnerableCount(vulnerabilities.size());

            // Update status to "Vulnerable" if vulnerabilities are found
            if (isVulnerable) {
                dependency.setStatus("Vulnerable");
            }

            dependencyRepository.save(dependency);

            // Add vulnerabilities to the database
            if (isVulnerable) {
                for (VulnerabilityResponse vulnResponse : vulnerabilities) {
                    Vulnerability vulnerability = Vulnerability.builder()
                            .dependency(dependency)
                            .name(vulnResponse.getName())
                            .description(vulnResponse.getDescription())
                            .severity(vulnResponse.getSeverity())
                            .affectedVersions(vulnResponse.getAffectedVersions())
                            .fixedInVersion(vulnResponse.getFixedInVersion())
                            .build();

                    vulnerabilityRepository.save(vulnerability);
                }

                log.info("Added {} vulnerabilities for {}:{}:{}",
                        vulnerabilities.size(), dependency.getGroupId(),
                        dependency.getArtifactId(), dependency.getCurrentVersion());
            }
        } catch (Exception e) {
            log.error("Error updating dependency vulnerabilities for {}:{}:{}",
                    dependency.getGroupId(), dependency.getArtifactId(),
                    dependency.getCurrentVersion(), e);
        }
    }

    /**
     * Helper inner class for passing dependency coordinates
     */
    @Getter
    @AllArgsConstructor
    private static class DependencyCoordinates {
        private final String groupId;
        private final String artifactId;
        private final String version;
    }
} 